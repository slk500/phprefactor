#+SETUPFILE: export/setup/theme-darksun-local.setup

#+Title: PHPRefactor

* Books
** Wake, William C.; Refactoring Workbook; 2003
*** https://xp123.com/articles/refactoring-workbook/
**** Taxonomy
***** [[http://mikamantyla.eu/BadCodeSmellsTaxonomy.html][Mika Mäntylä]]
***** [[http://www.industriallogic.com/wp-content/uploads/2005/09/smellstorefactorings.pdf][Joshua Kerievsky]]
** Feathers, Michael; Working Effectively with Legacy Code; 2005
 - To me, legacy code is simply code without tests. I’ve gotten some grief for this definition. What do tests have to do with whether code is bad? To me, the answer is straightforward, and it is a point that I elaborate throughout the book: 'Code without tests is bad code. It doesn’t matter how well written it is; it doesn’t matter how pretty or object-oriented or well-encapsulated it is. With tests, we can change the behavior of our code quickly and verifiably. Without them, we really don’t know if our code is getting better or worse.'

 - being able to confidently make changes in any code base.

 - Preserving existing behavior

 - Changes in a system can be made in two primary ways. I like to call them Edit and Pray and Cover and Modify. Unfortunately, Edit and Pray is pretty much the industry standard. When you use Edit and Pray, you carefully plan the changes you are going to make, you make sure that you understand the code you are going to modify, and then you start to make the changes. When you’re done, you run the system to see if the change was enabled, and then you poke around further to make sure that you didn’t break anything. The poking around is essential. When you make your changes, you are hoping and praying that you’ll get them right, and you take extra time when you are done to make sure that you did.

 - ...testing is a tough problem, and people are often seduced by the idea that they can test through a GUI or web interface without having to do anything special to their application. It can be done, but it is usually more work than anyone on a team is prepared to admit. In addition, a user interface often isn’t the best place to write tests. UIs are often volatile and too far from the functionality being tested. When UI-based tests fail, it can be hard to figure out why. Regardless, people  often spend considerable money trying to do all of their testing with those sorts of tools.
   
 - Pay now or pay more later

** Fowler, Martin; 2018
- With any introductory example, however, I run into a problem. If I pick a large program, describing it and how it is refactored is too complicated for a mortal reader to work through.(...) However, if I pick a program that is small enough to be comprehensible, refactoring does not look like it is worthwhile.
 
- Thus, if I’m faced with modifying a program with hundreds of lines of code, I’d rather it be structured into a set of functions and other program elements that allow me to understand more easily what the program is doing. If the program lacks structure, it’s usually easier for me to add structure to the program first, and then make the change I need.

- If the code works and doesn’t ever need to change, it’s perfectly fine to leave it alone. It would be nice to improve it, but unless someone needs to understand it, it isn’t causing any real harm. Yet as soon as someone does need to understand how that code works, and struggles to follow it, then you have to do something about it.

- Refactoring changes the programs in small steps, so if you make a mistake, it is easy to find where the bug is.

- Any fool can write code that a computer can understand. Good programmers write code that humans can understand.

- The true test of good code is how easy it is to change it.

- Refactoring (noun): a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior

- Refactoring (verb): to restructure software by applying a series of refactorings without changing its observable behavior.

- Refactoring is very similar to performance optimization, as both involve carrying out code manipulations that don’t change the overall functionality of the program. The difference is the purpose: Refactoring is always done to make the code “easier to understand and cheaper to modify.” This might speed things up or slow things down. With performance optimization, I only care about speeding up the program, and am prepared to end up with code that is harder to work with if I really need that improved performance.

- Without refactoring, the internal design—the architecture—of software tends to decay.As people change code to achieve short­term goals, often without a full comprehensionof the architecture, the code loses its structure. It becomes harder for me to see thedesign by reading the code. Loss of the structure of code has a cumulative effect. Theharder it is to see the design in the code, the harder it is for me to preserve it, and themore rapidly it decays. Regular refactoring helps keep the code in shape.

- It reminds me of a statement Kent Beck often makes about himself: “I’m not a great programmer; I’m just a good programmer with great habits.” Refactoring helps me be much more effective at writing robust code. 

- Branches. As I write this, a common approach in teams is for each team member to work on abranch of the code base using a version control system, and do considerable work onthat branch before integrating with a mainline (often called master or trunk) sharedacross the team. Often, this involves building a whole feature on a branch, notintegrating into the mainline until the feature is ready to be released into production.Fans of this approach claim that it keeps the mainline clear of any in­process code,provides a clear version history of feature additions, and allows features to be revertedeasily should they cause problems.There are downsides to feature branches like this. The longer I work on an isolatedbranch, the harder the job of integrating my work with mainline is going to be when I’mdone. Most people reduce this pain by frequently merging or re­basing from mainlineto my branch. But this doesn’t really solve the problem when several people areworking on individual feature branches. I distinguish between merging and integration.If I merge mainline into my code, this is a oneway movement—my branch changes butthe mainline doesn’t. I use “integrate” to mean a two­way process that pulls changesfrom mainline into my branch and then pushes the result back into mainline, changingboth. If Rachel is working on her branch I don’t see her changes until she integrateswith mainline; at that point, I have to merge her changes into my feature branch, whichmay mean considerable work. The hard part of this work is dealing with semanticchanges. Modern version control systems can do wonders with merging complexchanges to the program text, but they are blind to the semantics of the code. If I’vechanged the name of a function, my version control tool may easily integrate mychanges with Rachel’s. But if, in her branch, she added a call to a function that I’verenamed in mine, the code will fail.The problem of complicated merges gets exponentially worse as the length of featurebranches increases. Integrating branches that are four weeks old is more than twice ashard as those that are a couple of weeks old. Many people, therefore, argue for keepingfeature branches short—perhaps just a couple of days. Others, such as me, want themeven shorter than that. This is an approach called Continuous Integration (CI), alsoknown as Trunk­Based Development. With CI, each team member integrates withmainline at least once per day. This prevents any branches diverting too far from eachother and thus greatly reduces the complexity of merges. CI doesn’t come for free: Itmeans you use practices to ensure the mainline is healthy, learn to break large featuresinto smaller chunks, and use feature toggles (aka feature flags) to switch off any in­process features that can’t be broken down.Fans of CI like it partly because it reduces the complexity of merges, but the dominantreason to favor CI is that it’s far more compatible with refactoring. Refactorings ofteninvolve making lots of little changes all over the code base—which are particularlyprone to semantic merge conflicts (such as renaming a widely used function). Many ofus have seen feature­branching teams that find refactorings so exacerbate mergeproblems that they stop refactoring. CI and re­factoring work well together, which iswhy Kent Beck combined them in Extreme Programming.I’m not saying that you should never use feature branches. If they are sufficiently short,their problems are much reduced. (Indeed, users of CI usually also use branches, butintegrate them with mainline each day.) Feature branches may be the right techniquefor open source projects where you have infrequent commits from programmers whoyou don’t know well (and thus don’t trust). But in a full­time development team, thecost that feature branches impose on refactoring is excessive. Even if you don’t go to fullCI, I certainly urge you to integrate as frequently as possible. You should also considerthe objective evidence [Forsgren et al.] that teams that use CI are more effective insoftware delivery.

131
** Others  
   
  | author                                                                            | title                                                                                                                | topic       | info        | year |                                                                                                                                                                                                              |
  |-----------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------+-------------+-------------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | Andrew Hunt, David Thomas                                                         | The Pragmatic Programmer: From Journeyman to Master                                                                  | overall     | skip        | 1999 | a lot of tips & tricks but too old                                                                                                                                                                           |
  | William J. Brown, Raphael C. Malveau, Hays W. "Skip" McCormick, Thomas J. Mowbray | Antipatterns. Refactoring Software, Archtectures and Projects in Crisis                                              |             |             | 1998 |                                                                                                                                                                                                              |
  |                                                                                   | Refactoring in Large Software Projects                                                                               |             |             | 2006 |                                                                                                                                                                                                              |
  | Phillip A. Laplante, Colin J. Neill                                               | Antipatterns: Identification, Refactoring, and Management                                                            |             |             | 2005 |                                                                                                                                                                                                              |
  |                                                                                   | Fifty Quick Ideas To Improve Your Tests                                                                              | tests       |             |      |                                                                                                                                                                                                              |
  |                                                                                   | Growing Object-Oriented Software, Guided by Tests                                                                    |             |             |      |                                                                                                                                                                                                              |
  |                                                                                   | Working Effectively with Unit Tests                                                                                  |             |             |      |                                                                                                                                                                                                              |
  |                                                                                   | Scalable Internet Architectures                                                                                      |             |             |      |                                                                                                                                                                                                              |
  |                                                                                   | SQL for Smarties: Advanced SQL Programming                                                                           | database    |             | 2005 |                                                                                                                                                                                                              |
  |                                                                                   | Mastering the SPL Library                                                                                            |             |             |      |                                                                                                                                                                                                              |
  |                                                                                   | Anthology  The Thoughtworks Anthology - Essays on Software Technology and Innovation                                 |             |             | 2008 |                                                                                                                                                                                                              |
  |                                                                                   | Anthology  The ThoughtWorks Anthology 2 - More Essays on Software Technology and Innovation                          |             |             | 2012 |                                                                                                                                                                                                              |
  | Beck, Kent                                                                        | Extreme Programming Explained: Embrace Change                                                                        | overall     | can be read | 1999 |                                                                                                                                                                                                              |
  | Bernstein, David Scott                                                            | Beyond Legacy Code                                                                                                   |             |             | 2015 | Want to read                                                                                                                                                                                                 |
  | Bhargava, Aditya                                                                  | Grokking Algorithms: An illustrated guide for programmers and other curious people                                   |             | must read   | 2017 | Fully illustrated, friendly, easy to read guide, worth to read. When you will stumble upon a problem, you will know how to recognize it and chose the right Algorithm                                        |
  | Bloch, Joshua                                                                     | Effective Java                                                                                                       |             |             | 2018 |                                                                                                                                                                                                              |
  | Buenosvinos, Carlos                                                               | Domain-Driven Design in PHP                                                                                          |             |             | 2016 |                                                                                                                                                                                                              |
  | Bugayenko, Yegor                                                                  | Elegant Objects                                                                                                      |             |             | 2016 | Want to read                                                                                                                                                                                                 |
  | Fowler, Martin                                                                    | Refactoring: Improving the Design of Existing Code                                                                   | refactoring | must have   | 1999 |                                                                                                                                                                                                              |
  | Fowler, Martin                                                                    | Patterns of Enterprise Application Architecture                                                                      |             |             | 2012 |                                                                                                                                                                                                              |
  | Francesco Trucchia, Jacopo Romei                                                  | Pro PHP Refactoring                                                                                                  |             |             | 2010 | Old, without PHP 7 but still the best PHP book about refactoring. Great examples. Worth to have.                                                                                                             |
  | Ganesh, Samarthyam; Tushar, Sharma                                                | Refactoring for Software Design Smells: Managing Technical Debt                                                      |             |             | 2015 | Catalog of smells. Focus on smell point of view. Also they introduce smell classification scheme, naming scheme for design smells which helps to increase awerness of smells. So definetly must read. (Java) |
  | Halladay, Steve                                                                   | Principle-Based Refactoring: Learning Software Design Principles by Applying Refactoring Rules                       |             |             | 2012 | Want to read                                                                                                                                                                                                 |
  | Jones, Paul M.                                                                    | Modernizing Legacy Apps In PHP                                                                                       |             |             | 2014 |                                                                                                                                                                                                              |
  | Junade, Ali                                                                       | Mastering PHP Design Patterns                                                                                        |             |             | 2016 | Little bit inmature, poorly written. Having a lot of tips and information about broad variaty of things which is a good place on website but not in the book. Code examples could be much better.            |
  | Karwin, Bill                                                                      | SQL Antipatterns - Avoiding The Pitfalls of Database Programming                                                     | database    |             | 2010 |                                                                                                                                                                                                              |
  | Kerievsky, Joshua                                                                 | Refactoring to Patterns                                                                                              |             |             | 2004 |                                                                                                                                                                                                              |
  | Martin, Robert C.                                                                 | Agile Software Development: Principles, Patterns, and Practices                                                      |             |             | 2002 |                                                                                                                                                                                                              |
  | Martin, Robert C.                                                                 | Clean Code: A Handbook of Agile Software Craftsmanship                                                               |             |             | 2009 |                                                                                                                                                                                                              |
  | Rahman, Mizanur                                                                   | PHP 7 Data Structures and Algorithms                                                                                 | refactoring | must have   | 2017 |                                                                                                                                                                                                              |
  | Scott J Ambler and Pramod J. Sadalage                                             | Refactoring Databases - Evolutionary Database Design                                                                 | refactoring | must read   | 2006 | It's catalog of refactorings for database                                                                                                                                                                    |
  | Stephane Faroult, Pascal L'Hermite                                                | Refactoring SQL Application                                                                                          | database    |             | 2008 |                                                                                                                                                                                                              |
  | Tornhill, Adam                                                                    | Your Code as a Crime Scene - Use Forensic Techniques to Arrest Defects, Bottlenecks, and Bad Design in Your Programs |             |             | 2015 |                                                                                                                                                                                                              |
  | West, David                                                                       | Object Thinking                                                                                                      |             |             | 2004 |                                                                                                                                                                                                              |
  | Zandstra, Matt                                                                    | PHP Objects, Patterns, and Practice                                                                                  |             | can be read | 2008 | Pretty old. But written with precise language and with great examples                                                                                                                                        |
  
* Tutorials  
| [[https://www.pluralsight.com/courses/automated-tests-phpunit][Automated Tests with PHPUnit]]                     | Anna Filina              | testing - PHPUnit     |
| [[https://industriallogic.com/xp/refactoring/catalog.html][Catalog of Refactoring to Patterns]]               | Joshua Kerievsky         | patterns              |
| [[https://refactoring.com/catalog/][Catalog of Refactorings]]                          | Martin Fowler            | refactoring           |
| [[https://youtu.be/bkjIEywt45Y][Clean Application Development]]                    | Adam Culp                | clean application     |
| [[https://github.com/jupeter/clean-code-php][Clean Code PHP]]                                   | Piotr Plenik             | clean code            |
| [[https://code.tutsplus.com/courses/detecting-code-smells][Detecting Code Smells]]                            | Patkós Csaba             | refactoring           |
| [[https://youtu.be/WW2qPKukoZY][Doctrine Best Practices]]                          | Marco Pivetta (Ocramius) | doctrine              |
| [[https://www.pluralsight.com/courses/encapsulation-solid][Encapsulation and SOLID]]                          | Mark Seemann             | SOLID                 |
| [[https://youtu.be/7LoShYRnljU][Extremely Defensive PHP Programming]]              | Marco Pivetta (Ocramius) | defensive programming |
| [[https://youtu.be/Rdc3r2BJzWA][How to Refactor Like a Boss 1]]                    | Michael Cheng            | refactoring           |
| [[https://youtu.be/2iXayIx4WyQ][How to Refactor Like a Boss 2]]                    | Michael Cheng            | refactoring           |
| [[https://youtu.be/JCqbdVrIW30][HTTP Smoke Testing]]                               | Peter Heinz              | testing - smoke test  |
| [[https://www.udemy.com/introduction-to-testing-with-phpunit/][Introduction to Testing with PHPUnit]]             | Trevor Sawler            | testing - PHPUnit     |
| [[http://blog.adrianbolboaca.ro/2014/04/legacy-coderetreat/#sessions][Legacy Coderetreat (Java)]]                        | Adrian Bolboaca          | refactoring           |
| [[https://github.com/exakat/php-static-analysis-tools][List of Static Analysis Tools]]                    |                          | analysis              |
| [[https://www.lynda.com/PHP-tutorials/PHP-Testing-Legacy-Applications/669546-2.html][PHP: Testing Legacy Applications]]                 | Chris Hartjes            | testing - PHPUnit     |
| [[https://knpuniversity.com/screencast/phpunit][PHPUnit: Testing with a Bite]]                     | Ryan Weaver              | testing - PHPUnit     |
| [[https://www.lynda.com/Developer-Programming-Foundations-tutorials/Foundations-Programming-Refactoring-Code/122457-2.html][Programming Foundations: Refactoring Code]]        | Simon Allardice          | refactoring           |
| [[https://www.lynda.com/Software-Development-tutorials/Programming-Foundations-Test-Driven-Development/124398-2.html][Programming Foundations: Test-Driven Development]] | Simon Allardice          | testing - TDD         |
| [[https://youtu.be/0DYIJdX6kB4][Refactoring 101]]                                  | Adam Culp                | refactoring           |
| [[https://code.tutsplus.com/series/refactoring-legacy-code--cms-633][Refactoring Legacy Code]]                          | Patkós Csaba             | refactoring           |
| [[https://youtu.be/7v9ehGsPm1s][Refactoring Legacy Code]]                          | Adam Culp                | refactoring           |
| [[https://adamwathan.me/refactoring-to-collections/][Refactoring to Collections]]                       | Adam Wathan              | collections           |
| [[https://youtu.be/Fca-Ng0bzuk][Solving the N+1 Problem]]                          | Paul M. Jones            | database              |
| [[https://youtu.be/65NrzJ_5j58][Steps Toward Modernizing a Legacy Codebase]]       | Paul M. Jones            | refactoring           |
| [[https://code.tutsplus.com/courses/techniques-for-refactoring-code][Techniques for Refactoring Code]]                  | Patkós Csaba             | refactoring           |
* Refactorings
** Add PHPDoc
     Smell: An array with elements of generic type or method which can throw Exception
#+BEGIN_SRC php
public function printUsersNames(array $users): void
{
    foreach ($users as $user) {
        echo $user->getName();
    }
}
#+END_SRC
*** Refactor the code
      Add PHPDoc - the Object[] notation in addition to an array type-hint to explain what kind of object is expected
#+BEGIN_SRC php
/**
 ,* @param User[] $users
 ,*/
public function printUsersNames(array $users): void
{
    foreach ($users as $user) {
        echo $user->getName();
    }
}
#+END_SRC
** Add Type-Hint
     Smell: A method with no type defined parameters or return type declaration
#+BEGIN_SRC php
public function setNumber($number)
{
    $this->number = $number;
}
#+END_SRC
*** Refactor the code
#+BEGIN_SRC php
public function setNumber(int $number): void
{
    $this->number = $number;
}
#+END_SRC
*** Helper 
    [[https://github.com/dunglas/phpdoc-to-typehint][phpdoc-to-typehint]] adds automatically scalar type hints and return types to all functions and methods using existing PHPDoc annotations 
*** Further Reading 
    https://www.thecodingmachine.com/type-hint-all-the-things/
** Consolidate Conditional Expression
     Smell: Sequence of conditionals with the same result
#+BEGIN_SRC php
class Sale
{
    public function calculateShipping(Customer $customer)
    {
        if ($customer->isEmployee) return 0;
        if ($customer->isGoldCustomer) return 0;
        if ($customer->isHasACoupon) return 0;
        
        if($isUsa) return 10;
        if($isEurope) return 20;
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
      Combine them into a single conditional expression and extract it.
#+BEGIN_SRC php
class Sale
{
    public function calculateShipping(Customer $customer): int
    {
       if ($this->isFreeShipping()){
           return 0;
       }

        if($isUsa) {
            return 10;
        }

        if($isEurope) {
            return 20;
        }
    }

    private function isFreeShipping(): bool
    {
        return ($customer->isEmployee || $customer->isGoldCustomer || $customer->isHasACoupon);
    }
}
#+END_SRC
*** Pass a test
** Consolidate Duplicate Conditional Fragments
     Smell: The same fragment of code is in all branches of a conditional expression.
#+BEGIN_SRC php
final class Sale
{
    public function calculateTotal(int $price)
    {
        if ($this->isSpecialDeal()) {
            $total = $price * 0.95;
            $this->setTotal($total);
        }
        else {
            $total = $price * 0.98;
            $this->setTotal($total);
        }
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
      Move it outside of the expression.
#+BEGIN_SRC php
final class Sale
{
    public function calculateTotal(int $price)
    {
        if ($this->isSpecialDeal()) {
            $total = $price * 0.95;
        }
        else {
            $total = $price * 0.98;
        }

        $this->setTotal($total);
    }
}
#+END_SRC
*** Pass a test
** Decompose Conditional
     Smell: Complicated conditional (if-else) statement.
#+BEGIN_SRC php
class Sale
{
    public $expired_at;
    public $amount;

    public function getAmount()
    {
        if(null !== $this->expired_at && $this->expired_at < time())
        {
            $interest = 10;
            $this->amount = $this->amount + ($this->amount / 100 * $interest);
        }
        else
        {
            $discount = 10;
            $this->amount = $this->amount - ($this->amount / 100 * $discount);
        }
        return $this->amount;
    }
}
#+END_SRC
*** Write a test that pass
#+BEGIN_SRC php
class SaleTest extends TestCase
{
    public function testAmount()
    {
        $sale = new Sale();
        $sale->amount = 10;
        $sale->expired_at = strtotime('-10 days');
        $this->assertEquals(10 + (10 / 100 * 10), $sale->getAmount());
        $sale = new Sale();

        $sale->amount = 10;
        $sale->expired_at = strtotime('+10 days');
        $this->assertEquals(10 - (10 / 100 * 10), $sale->getAmount());
    }
}
#+END_SRC
*** Refactor the code
Extract conditional code in a private method. We name the method isExpired() because our conditional chunk of code checks if the sale is expired. We create the private method isExpired() and, with the technique of extract method, we move chunks of code into the new method. The next step is to move each branch of the condition in a private method. We do the same as we did before for each branch. So we create the private method getAmountWithInterest() for the first branch and the method getAmountWithDiscount() for the second branch.
#+BEGIN_SRC php
class Sale
{
    public $expired_at;
    public $amount;

    public function getAmount()
    {
        if ($this->isExpired()) {
            return $this->getAmountWithInterest();
        } else {
            return $this->getAmountWithDiscount();
        }
    }

    private function isExpired()
    {
        return !is_null($this->expired_at) && $this->expired_at < time();
    }

    private function getAmountWithInterest()
    {
        $interest = 10;
        return $this->amount + ($this->amount / 100 * $interest);
    }

    private function getAmountWithDiscount()
    {
        $discount = 10;
        return $this->amount - ($this->amount / 100 * $discount);
    }
}
#+END_SRC
*** Pass a test
** Encapsulate Field
     Smell: A public field
#+BEGIN_SRC php
final class User
{
    /**
     ,* @var string
     ,*/
    public $name;
}
#+END_SRC
*** Write a test that pass
*** Refactor the code
      Make it private and provide accessors.
#+BEGIN_SRC php
final class User
{
    /**
     ,* @var string
     ,*/
    private $name;

    public function getName(): string
    {
        return $this->name;
    }

    public function setName(string $name): void
    {
        $this->name = $name;
    }
}
#+END_SRC
*** Run a test
** Extract Class
   SmellL Large Class
#+BEGIN_SRC php
final class User
{
    private $name;
    private $surname;

    private $city;
    private $zipCode;
    private $street;
    private $state;
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
      Create a new class and move the relevant fields and methods from the old class into the new class.
#+BEGIN_SRC php
final class User
{
    private $name;
    private $surname;

    private $address;
}

final class Address
{
    private $city;
    private $zipCode;
    private $street;
    private $state;
}
#+END_SRC
*** Pass a test
** Extract Function
   Alias: Extract Method
   Inverse of: Inline Function
   Smell: Code fragment that can be grouped together
#+BEGIN_SRC php
public function printInvoice(Invoice $invoice): void
{
    echo 'Invoice';
    echo '<br>';
    echo $invoice->getNumber();
   
    echo 'phpRefactor: ';
    echo '<br>';
    echo $invoice->getDate();
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
      Turn the fragment into a method whose name explains the purpose of the method
#+BEGIN_SRC php
public function printInvoice(Invoice $invoice): void
{
    printInvoiceHeader($invoice);
    printInvoiceFooter($invoice);
}

function printInvoiceHeader(Invoice $invoice): void
{
    echo 'Invoice';
    echo '<br>';
    echo $invoice->getNumber();
}

function printInvoiceFooter(Invoice $invoice): void
{
    echo 'phpRefactor: ';
    echo '<br>';
    echo $invoice->getDate();
}



#+END_SRC
*** Run a test
*** Notes
#+BEGIN_SRC php
function printInvoice() {
    $footer=function() {
        echo "phpRefactor.com \n";
        echo "2019";
    };
    
    echo "Header \n";
    $footer();
}
printInvoice();

#+END_SRC

** Extract Variable
   Alias: Introduce Explaining Variable
   Smell: Complicated expression
#+BEGIN_SRC php
if(($stock->checkStatus($order->getItem) > $order->getQuantity()) 
    && ($order->getTotal() > 99) 
    && ($order->getCustomer()->getBillingAddress() === $order->getShippingAddress()));
#+END_SRC
*** Write a test that pass
*** Refactor the code
    Put the result of the expression, or part of it in a temporary variable with a name that explains the purpose
#+BEGIN_SRC php
$freeShipping = $order->getTotal() > 99;
$stockAvailable = $stock->checkStatus($order->getItem) > $order->getQuantity();
$addressMatches = $order->getCustomer()->getBillingAddress() === $order->getShippingAddress();
if($stockAvailable && $freeShipping && $addressMatches);
#+END_SRC
*** Pass a test
** Inline Class
   Smell: A class isn't doing very much
#+BEGIN_SRC php
final class User
{
    private $name;
    private $surname;

    private $telephoneNumber;
}

final class TelephoneNumber
{
    private $number;
}
#+END_SRC
** DONE Inline Function
   Smell: A function's body is just as clear as it's name
#+NAME: inline_function
#+BEGIN_SRC php
class Circle
{
    public const RADIUS = 2;

    public function getArea(): float
    {
        return $this->getValueOfPI() * self::RADIUS * self::RADIUS;
    }

    private function getValueOfPI(): float
    {
        return pi();
    }
}
#+END_SRC
*** Write a test that pass
 #+NAME: inline_function_test
#+BEGIN_SRC phpunit :noweb yes :noweb strip-export :exports both
<<inline_function>>
use PHPUnit\Framework\TestCase;

class CircleTest extends TestCase
{   
    public function testGetArea()
    {
        $circle = new Circle();
        $this->assertEquals( 12.566370614359172, $circle->getArea());
    }
}
 #+END_SRC

 #+RESULTS: inline_function_test
 : PHPUnit 7.4.3 by Sebastian Bergmann and contributors.
 : 
 : .                                                                   1 / 1 (100%)
 : 
 : Time: 53 ms, Memory: 10.00MB
 : 
 : OK (1 test, 1 assertion)

*** Refactor the code 
    Put the method's body into the body of its callers and remove the method.
#+BEGIN_SRC php
public function getArea(): float
{
    return pi() * $radius * $radius;
}
 #+END_SRC
*** Pass a test
** Inline Variable
   Smell: Variable name doesn't really communicate more than the expression itself or gets in the way of refactoring neighboring code.
#+BEGIN_SRC php
let basePrice = anOrder.basePrice;
return (basePrice > 1000);
#+END_SRC
*** Refactor the code
#+BEGIN_SRC php
return anOrder.basePrice > 1000;
#+END_SRC
140
** Introduce Parameter Object
   Smell: Long Parameter List and parameters that naturally go together
#+BEGIN_SRC php
final class Account
{
    public function findAllTransactions(DateTime $start, DateTime $end)
    {
        ...
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
    Replace them with an object.
#+BEGIN_SRC php#+END_SRC
*** Pass a test
** Optimize Imports
   Smell: Imports unused or not in alphabetically order. Multiple use statement
#+BEGIN_SRC php
use SomeClass\Worker;
use SomeClass\Foo;
use SomeClass\UnusedClass;
#+END_SRC
*** Write a test that pass
*** Refactor the code 
    Remove unused imports. Sort imports alphabetically (ascending order). Splits multiple use statement imports into single use statement imports
#+BEGIN_SRC php
use SomeClass\{Foo, Worker};
 #+END_SRC
*** Pass a test

** Move Method
   Smell: Method accessing fields and methods in different class
   #+BEGIN_SRC php
final class Customer
{
    function printInvoice(Order $order)
    {
        echo "Invoice {$order->getId()}";
        echo "Date: {$order->getDate()}";
        echo "Customer: {$this->getName()}";

        $address = $order->getAddress();
        echo "City: {$address->getCity()}";
        echo "Address: {$address->getStreet()}";

        foreach ($order->getItems() as $item){

            echo "Name: {$item->getName()}";
            echo "Price: {$item->getPrice()}";
        }
    }
}   
   #+END_SRC
*** Write a test that pass
*** Refactor the code 
    Move all its features into another class and delete it.
#+BEGIN_SRC php
final class Order
{
    function printInvoice()
    {
        echo "Invoice {$this->getId()}";
        echo "Date: {$this->getDate()}";
        echo "Customer: {$this->getCustomer()->getName()}";

        $address = $this->getAddress();
        echo "City: {$address->getCity()}";
        echo "Address: {$address->getStreet()}";

        foreach ($this->getItems() as $item){

            echo "Name: {$item->getName()}";
            echo "Price: {$item->getPrice()}";
        }
    }
}
 #+END_SRC
*** Pass a test
** Parameterize Method
   Smell: Several methods do similar things but with different values contained in the method body.
#+BEGIN_SRC php
final class Employee
{
    /**
     * @var float
     */
    private $salary;

    public function setSalary(float $salary)
    {
        $this->salary = $salary;
    }

    public function getSalary(): float
    {
        return $this->salary;
    }

    public function fivePercentRaise()
    {
        $this->salary += $this->salary* (5 / 100);
    }

    public function tenPercentRaise()
    {
        $this->salary += $this->salary* (10 / 100) ;
    }
}
#+END_SRC
*** TODO Write a test that pass
*** Refactor the code 
Create one method that uses a parameter for the different values.
#+BEGIN_SRC php
final class Employee
{
    /**
     * @var float
     */
    private $salary;

    public function setSalary(float $salary)
    {
        $this->salary = $salary;
    }

    public function getSalary(): float
    {
        return $this->salary;
    }

    public function raise(float $percent)
    {
        $this->salary += $this->salary * ($percent / 100);
    }
}
 #+END_SRC
*** Pass a test
** Preserve Whole Object
   Smell: More than one value from an object are passing as parameters in a method call
#+BEGIN_SRC php
class September
{
    /**
     * @var float
     */
    private $highestTemp;

    /**
     * @var float
     */
    private $lowestTemp;

    public function __construct(float $highestTemp, float $lowestTemp)
    {
        $this->highestTemp = $highestTemp;
        $this->lowestTemp = $lowestTemp;
    }

    public function getHighestTemp(): float
    {
        return $this->highestTemp;
    }

    public function getLowestTemp(): float
    {
        return $this->lowestTemp;
    }
}

class Calculator
{
    public function calculateAverageTemperature(float $highestTemp, float $lowestTemp)
    {
        return ($highestTemp + $lowestTemp) / 2;
    }
}

$september = new September(15,5);
$calculator = new Calculator();

$averageTemperature = $calculator->calculateAverageTemperature(
            $september->getHighestTemp(),
            $september->getLowestTemp()
        );
#+END_SRC
*** Write a test that pass
#+BEGIN_SRC php
public function testCalculateAverageTemperature()
{
        $september = new September(15,5);
        $calculator = new Calculator();

        $averageTemperature = $calculator->calculateAverageTemperature(
            $september->getHighestTemp(),
            $september->getLowestTemp());

        $this->assertEquals(10, $averageTemperature);
}
#+END_SRC
*** Refactor the code
    Add object as a new parameter. Set it default value to null, that will help to manage the transitions towards the final version of the method.
#+BEGIN_SRC php
class Calculator
{
    public function calculateAverageTemperature(float $highestTemp, float $lowestTemp, September $september = null)
    {
        return ($highestTemp + $lowestTemp) / 2;
    }
}
#+END_SRC
*** Pass a test
*** Refactor the code
    Replace values with values coming from the whole object
#+BEGIN_SRC php
class Calculator
{
    public function calculateAverageTemperature(float $highestTemp, float $lowestTemp, September $september = null)
    {
        return ($september->getHighestTemp() + $september->getLowestTemp()) / 2;
    }
}
#+END_SRC
*** Pass a test
*** Refactor the code
    Remove useless parameters and default null value of $september object
#+BEGIN_SRC php
class Calculator
{
    public function calculateAverageTemperature(September $september)
    {
        return ($september->getHighestTemp() + $september->getLowestTemp()) / 2;
    }
}
#+END_SRC
*** Pass a test
** Pull Up Method
   Smell: Subclasses have the same method.
#+BEGIN_SRC php
class Employee
{
    /**
     * @var string
     */
    protected $name;
    
    public function __construct(string $name)
    {
        $this->name = $name;
    }
}

final class Salesman extends Employee
{
    public function getName()
    {
        return $this->name;
    }
}

final class Engineer extends Employee
{
    public function getName()
    {
        return $this->name;
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
    Move the methods to the super class.
#+BEGIN_SRC php
class Employee
{
    /**
     * @var string
     */
    protected $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function getName()
    {
        return $this->name;
    }
}

final class Salesman extends Employee {}

final class Engineer extends Employee {}
 #+END_SRC
*** Pass a test
** Remove Assignments to Parameters
   Smell: Reassign to a parameter
   #+BEGIN_SRC php
public function discount(int $priceTotal): int
{
    if ($priceTotal > 100) {
        $priceTotal = $priceTotal - 10;
    }
    
    return $priceTotal;
}  
   #+END_SRC
*** Write a test that pass
*** Refactor the code 
    Use a temporary variable instead
#+BEGIN_SRC php
public function discount(int $priceTotal): int
{
    $result = $priceTotal;

    if ($priceTotal > 100) {
        $result = $result - 10;
    }

    return $result;
}
#+END_SRC
*** Pass a test
*** Info
    The best practice is that if you pass parameters into a method then they should always represent what were passed in and never be reassigned to mean something else. Btw. in Java you can prevent variable’s reassignment by keyword 'final' before a parameter https://stackoverflow.com/questions/500508/why-should-i-use-the-keyword-final-on-a-method-parameter-in-java
** Remove PHPDoc
   Smell: PHPDoc is duplicating type-hint information
   Damage: Adds information which not provides additional value
   #+BEGIN_SRC php
/**
 * @param int $number
 * @return void
 */
public function setNumber(int $number): void
{
    $this->number = $number;
}  
   #+END_SRC
*** Write a test that pass
*** Refactor the code 
Remove PHPDoc if it's not provides additional value
#+BEGIN_SRC php

#+END_SRC
*** Pass a test
** Rename Function
   Alias: Rename Method, Change Function Declaration
   Smell: The name of a method does not reveal it's purpose1
#+BEGIN_SRC php
public function getInvcdtlmt()
#+END_SRC

*** Write a test that pass
*** Refactor the code 
    Change the name of the method
#+BEGIN_SRC php
public function getInvoiceableCreditLimit()
#+END_SRC
*** Pass a test
** Replace Global with Dependency Injection
   Smell: Variable with 'global' keyword
#+BEGIN_SRC php
final class Item
{
    public function fetch()
    {
        global $db;
        return $db->query(...);
    }
}
#+END_SRC

*** Write a test that pass
*** Refactor the code 
    Move global variable in class to the constructor
#+BEGIN_SRC php
final class Item
{
    /**
     * @var Database
     */
    private $db;

    public function __construct(Database $db)
    {
        $this->db = $db;
    }

    public function fetch()
    {
        return $db->query(...);
    }
}
#+END_SRC
*** Pass a test
** DONE Replace Magic Number With Symbolic Constant
   Smell: Number with a particular meaning
    #+NAME: replace_magic_number_with_symbolic_constant
     #+BEGIN_SRC php
final class Circle
{
    /**
     ,* @var float
     ,*/
    private $radius;
    
    public function __construct(float $radius)
    {
		$this->radius = $radius;
    }
    
    public function getCircumference(): float
    {
		return $this->radius * 2 * 3.1416;
    }
}
     #+END_SRC
*** Write a test that pass
    #+NAME: init_block_test
    #+BEGIN_SRC phpunit :noweb yes :noweb strip-export :exports both
<<replace_magic_number_with_symbolic_constant>>
use PHPUnit\Framework\TestCase;

class CircleTest extends TestCase
{   
    public function testGetCircumference()
    {
        $circle = new Circle(2);
        $this->assertEquals(12.5664, $circle->getCircumference());
    }
}
    #+END_SRC

    #+RESULTS:
    : PHPUnit 7.5.2 by Sebastian Bergmann and contributors.
    : 
    : .                                                                   1 / 1 (100%)
    : 
    : Time: 151 ms, Memory: 10.00MB
    : 
    : OK (1 test, 1 assertion)

*** Refactor the code 
    Create a constant, name it after the meaning, and replace the number with it
    #+BEGIN_SRC php
final class Circle
{
    /**
     ,* @var float
     ,*/
    private const PI = 3.1416;

    /**
     ,* @var float
     ,*/
    private $radius;

    public function __construct(float $radius)
    {
		$this->radius = $radius;
    }

    public function getCircumference(): float
    {
		return $this->radius * 2 * self::PI;
    }
}
    #+END_SRC
*** Run a test 
    #+RESULTS: init_block_test 
*** Helper:  
    [[https://github.com/povils/phpmnd][PHP Magic Number Detector]] is a tool to detect magic numbers in your PHP code
** Replace Parameter with Method
   Smell: A method runs different code depending on the values of parameters
#+BEGIN_SRC php
final class EmailNotification
{
    public function send(string $to, string $body, string $from = null)
    {
        if($from){
            $this->mailer->send($to, $body, $from);
        }else{
            $this->mailer->send($to, $body, $this->defaultSender);
        }
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
    Create a separate method for each value of the parameter
#+BEGIN_SRC php
final class EmailNotification
{
    public function send(string $to, string $body, string $from)
    {
        $this->mailer->send($to, $body, $from);
    }
    
    public function sendFromDefaultSender(string $to, string $body)
    {
        $this->mailer->send($to, $body, $this->defaultSender);
    }
}
#+END_SRC
*** Pass a test
** Replace Temp with Query
   Smell: Using a temporary variable to hold the result of an expression.
   Damage: Temporary variable increase the temptation to write longer methods. Temporaries aren’t necessarily bad, but sometimes they attract new code.
#+BEGIN_SRC php
public function getTotalPrice(): int
{
    $basePrice = $this->quantity * $this->itemPrice;

    if ($basePrice > self::DISCOUNT_POINT) {
        return $basePrice * self::DISCOUNT;
    }
    return $basePrice;
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
    Extract the expression into a method. Replace all references to the temp with the expression. The new method can then be used in other methods.
#+BEGIN_SRC php
public function getTotalPrice(): int
{
    if ($this->getBasePrice() > self::DISCOUNT_POINT) {
        return $this->getBasePrice() * self::DISCOUNT;
    }
    return $this->getBasePrice();
}

public function getBasePrice(): int
{
    $this->quantity * $this->itemPrice;
}
#+END_SRC
*** Pass a test
*** Info 
    Now, but wait, you might say. Isn't this more inefficient? Because if we created the temp the old way, we'd only have to execute the expression once, but if we turn it into a method, we might be calling it many different times. And yes, you're absolutely right, but remember, the pure efficiency of the code is not our first goal in refactoring. Clarity is. The likelihood is that a typical expression you would deal with in this sort of refactoring is going to be so undemanding, it wouldn't be noticeable at all, even having to call it several more times. But if it is an intensive operation, an intensive expression, well you should really be working on that later, after you've refactored using profilers. And other tools to make sure you're not doing pointless, premature optimization. And the real benefit is that by creating this as its own method, we will also have use of it anywhere else in the class, which wasn't the case before. As the original temp was scoped to the original method. So, we won't be tempted to add more code to the original method just to have access to that temp.
** Replacing Type Code with Subclasses
   Smell: Immutable type code affecting the class behavior.
#+BEGIN_SRC php
final class Account
{
    /**
     * @var int
     */
    private $accountType;

    /**
     * @var float
     */
    private $balance;

    /**
     * @var int
     */
    public const CHECKING = 0;

    /**
     * @var int
     */
    public const SAVINGS = 1;

    /**
     * @var int
     */
    public const INVESTMENT = 2;

    public function __construct(int $accountType)
    {
        $this->accountType = $accountType;
    }

    public function getAccountType(): int
    {
        return $this->accountType;
    }

    public function getBalance(): float
    {
        return $this->balance;
    }

    public function withdraw(float $amount): void
    {
        switch ($this->accountType){
            case self::CHECKING:
                $this->balance -= $amount;
                break;
            case self::SAVINGS:
                $this->balance -= $amount + 100;
                break;
            case self::INVESTMENT:
                $this->balance -= $amount + 300;
                break;
            default:
                throw new RuntimeException('Unknown Account Type');
        }
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code 
    Replace the type code with subclasses.
#+BEGIN_SRC php
abstract class Account
{
    /**
     * @var float
     */
    private $balance;

    public function getBalance(): float
    {
        return $this->balance;
    }
    
    abstract public function withdraw(float $amount): void
}

final class AccountChecking extends Account
{
    public function withdraw(float $amount): void
    {
        $this->balance -= $amount;
    }
}

final class AccountSavings extends Account
{
    public function withdraw(float $amount): void
    {
        $this->balance -= $amount + 100;
    }
}

final class AccountInvestment extends Account
{
    public function withdraw(float $amount): void
    {
        $this->balance -= $amount + 300;
    }
}
#+END_SRC
*** Pass a test
** Separate Query from Modifier
   Smell: A method that returns a value but also changes the state of an object.
#+BEGIN_SRC php
final class Account
{
    /**
     * @var float
     */
    private $balance;
    
    public function withdrawAndGetBalance(float $amount): float
    {
        $this->balance -= $amount;
        return $this->balance;
    }
}
#+END_SRC
*** Write a test that pass
*** Refactor the code
    Create two methods, one for the query and one for the modification.
#+BEGIN_SRC php
final class Account
{
    /**
     * @var float
     */
    private $balance;

    public function getBalance(): float
    {
        return $this->balance;
    }

    public function withdraw(float $amount): void
    {
        $this->balance -= $amount;
    }
}
#+END_SRC
*** Pass a test
** Split Temporary Variable
   Smell: Temporary variable is assigned to more than once (overwrite), but is not a loop variable nor a collecting temporary variable.
#+BEGIN_SRC php
$temp = $item.getPrice() * item.getQuantity();
echo "Total: $temp";
$temp = order.getTotal() - order.getDiscount();
echo "Price after discount: $temp;"
#+END_SRC
*** Write a test that pass
*** Refactor the code
    Make a separate temporary variable for each assignment.
#+BEGIN_SRC php
$totalPrice = $item.getPrice() * item.getQuantity();
echo "Total: $totalPrice";
$totalDiscountPrice = order.getTotal() - order.getDiscount();
echo "Price after discount: $totalDiscountPrice";
#+END_SRC
*** Pass a test
* Database
** Refactorings
*** Add CRUD Methods 
    Introduce stored procedures (methods) to implement the creation,
    retrieval, update, and deletion (CRUD) of the data representing a business entity.
*** Add Foreign Key Constraint
    Add a foreign key constraint to an existing table to enforce
    a relationship to another table.
*** Add Lookup Table
    Create a lookup table for an existing column.
*** Add Mirror Table
    Create a mirror table, an exact duplicate of an existing table in one
    database, in another database.
*** Add Parameter
    Existing method needs information that was not passed in before.
*** Add Read Method 
    Introduce a methodin this case, a stored procedureto implement the
    retrieval of the data representing zero or more business entities from the database.
*** Add Trigger For Calculated Column 
    Introduce a new trigger to update the value
    contained in a calculated column.
*** Apply Standard Codes 
    Apply a standard set of code values to a single column to ensure
    that it conforms to the values of similar columns stored elsewhere in the database.
*** Apply Standard Type
    Ensure that the data type of a column is consistent with the data
    type of other similar columns within the database.
*** Consolidate Conditional Expression 
    Combine sequence of conditional tests into a
    single conditional expression and extract it.
*** Consolidate Key Strategy 
    Choose a single key strategy for an entity and apply it
    consistently throughout your database.
*** Decompose Conditional
    Extract methods from the condition.
*** Drop Column 
    Remove a column from an existing table.
*** Drop Column Constraint 
    Remove a column constraint from an existing table.
*** Drop Default Value 
    Remove the default value that is provided by a database from an
    existing table column.
*** Drop Foreign Key Constraint 
    Remove a foreign key constraint from an existing table so
    that a relationship to another table is no longer enforced by the database.
*** Drop Non-Nullable 
    Change an existing non-nullable column so that it accepts null
    values.
*** Drop Table 
    Remove an existing table from the database.
*** Drop View 
    Remove an existing view.
*** Encapsulate Table With View 
    Wrap access to an existing table with a view.
*** Extract Method 
    Turn the code fragment into a method whose name explains the
    purpose of the method.Insert Data (page 296): Insert data into an existing table.
*** Introduce Calculated Column 
    Introduce a new column based on calculations involving
    data in one or more tables.
*** Introduce Calculation Method
    Introduce a new method, typically a stored function,
    which implements a calculation that uses data stored within the database.
*** Introduce Cascading Delete
    Ensure that the database automatically deletes the
    appropriate "child records" when a "parent record" is deleted.
*** Introduce Column Constraint
    Introduce a column constraint in an existing table.
*** Introduce Common Format
    Apply a consistent format to all the data values in an
    existing table column.
*** Introduce Default Value 
    Let the database provide a default value for an existing table
    column.
*** Introduce Hard Delete 
    Remove an existing column which indicates that a row has been
    deleted and instead actually delete the row.
*** Introduce Index 
    Introduce a new index of either unique or non-unique type.
*** Introduce New Column 
    Introduce a new column in an existing table.
*** Introduce New Table 
    Introduce a new table in an existing database.
*** Introduce Read-Only Table 
    Create a read-only data store based on existing tables in
    the database.
*** Introduce Soft Delete 
    Introduce a flag to an existing table which indicates that a row
    has been deleted instead of actually deleting the row.
**** Motivation 
     preserve all application data, typically for historical means.
**** Tradeoffs 
***** more data - table have to store valid rows and those mark as deleted 
***** performace - more data means reduction in query performace - the additional work of distinguishing between deleted and nondeleted rows
***** code complexity 
****** mostly in every query we would have to remember add 'where isDeleted = false'
****** You may have associations going from Table A to Table B and when you soft delete something from Table A, you need to ensure that independent queries on Table B take care of that fact. 
**** How
***** Introduce New Column
****** isDeleted 
******* bool not null false 
******* date/timestamp null
***** Update 
****** application 
****** database trigger - it is simple and it avoids the risk that the applications will not update the column properly      
**** Opposite
     Introduce Hard Delete
*** Introduce Surrogate Key 
    Replace an existing natural key with a surrogate key.
*** Introduce Trigger For History 
    Introduce a new trigger to capture data changes for historical purposes.
**** Motivation
     delegate the tracking of data changes to the database itself
   
*** Introduce Variable 
    Put the result of the expression, or parts of the expression, in a
    temporary variable with a name that explains the purpose.
*** Introduce View 
    Create a view based on existing tables in the database.
**** Motivation
***** Summarize data for reporting. Many reports require summary data, which can be generated via the view definition.
***** Replace redundant reads. Several external programs, or stored procedures for that matter, often implement the same retrieval query. These queries can be replaced by a common readonly table or view.
***** Data security. A view can be used to provide end users with read access to data but not update privileges.
***** Encapsulate access to a table. Some organizations choose to encapsulate access to tables by defining updateable views that external programs access instead of the source tables. This enables the organization to easily perform database refactorings such as Rename Column (page 109) or Rename Table (page 113) without impacting the external applications, because views add an encapsulation layer between your tables and your application.
***** Reduce SQL duplication. When you have complex SQL queries in an application, it is common to discover that parts of the SQL are duplicated in many places. When this is the case, you should introduce views to extract out the duplicate SQL, as shown in the example section.

**** Tradeoffs
***** poor performance of the joins
***** increases the coupling with database schemas

*** Make Column Non-Nullable 
    Change an existing column so that it does not accept any
    null values.
*** Merge Columns 
    Merge two or more columns within a single table.
*** Merge Tables
    Merge two or more tables into a single table.
*** Migrate Method From Database
    Rehost an existing database method (a stored
    procedure, stored function, or trigger) in the application(s) which currently invoke it.
*** Migrate Method To Database 
    Rehost existing application logic in the database.
*** Move Column 
    Migrate a table column, with all of its data, to another existing table.
*** Move Data 
    Move the data contained within a table, either all or a subset of its columns,
    to another existing table.
*** Parameterize Method 
    Create one method that uses a parameter for the different
    values.
*** Remove Control Flag 
    Use return or break instead of a variable acting as a control flag.
*** Remove Middle Man 
    Get the caller to call the method directly.
*** Remove Parameter 
    Remove a parameter no longer used by the method body.
*** Rename Column
    Rename an existing table column with a name that explains its purpose.
*** Rename Method
    Rename an existing method with a name that explains its purpose.
*** Rename Table
    Rename an existing table with a name that explains its purpose.
*** Rename View
    Rename an existing view with a name that explains its purpose.
*** Reorder Parameters 
    Change the order of the parameters of a method.
*** Replace Column 
    Replace an existing non-key column with a new one.
*** Replace LOB With Table 
    Replace a large object (LOB) column that contains structured data with a new table or in the same table.
*** Replace Literal With Table Lookup 
    Replace code constants with values from database tables.
*** Replace Method(s) With View 
    Create a view based on one or more existing database
    methods (stored procedures, stored functions, or triggers) within the database.
*** Replace Nested Conditional With Guard Clauses 
    Remove nested if conditions with a series of separate IF statements.
*** Replace One-To-Many With Associative Table 
    Replace a one-to-many association between two tables with an associative table.
*** Replace Parameter With Explicit Methods 
    Create a separate method for each value of the parameter.
*** Replace Surrogate Key With Natural Key 
    Replace a surrogate key with an existing natural key.
*** Replace Type Code With Property Flags 
    Replace a code column with individual property flags, usually implemented as Boolean columns, within the same table column.
*** Replace View With Method(s) 
    Replace an existing view with one or more existing
    methods (stored procedures, stored functions, or triggers) within the database.
*** Split Column 
    Split a column into one or more columns within a single table.
*** Split Table 
    Vertically split (e.g., by columns) an existing table into one or more tables.
*** Split Temporary Variable 
    Make a separate temporary variable for each assignment.
*** Substitute Algorithm 
    Replace the body of the method with the new algorithm.
*** Update Data 
    Update data within an existing table.
*** Use Official Data Source 
    Use the official data source for a given entity, instead of the
    current one you are using.
** Links
- https://use-the-index-luke.com/
** views 
 select y.table_schema,
	y.table_name,
	y.view_len,
	y.referenced_views
                                                           views,
	cast((y.view_len - y.wo_from) / 4 - 1 as unsigned) subqueries,
	cast((y.view_len - y.wo_union) / 5 as unsigned)
                                                           unions,
	cast((y.view_len - y.wo_distinct) / 8 as unsigned) distincts,
	cast((y.view_len - y.wo_group) / 5 as unsigned)
                                                           groups
 from (select x.table_schema,
              x.table_name,
              x.view_len,
              cast(x.referenced_views as unsigned) referenced_views,
              length(replace(upper(x.view_definition), 'FROM', '')) wo_from,
              length(replace(upper(x.view_definition), 'UNION', '')) wo_union,
              length(replace(upper(x.view_definition), 'DISTINCT', '')) wo_distinct,
              length(replace(upper(x.view_definition), 'GROUP', '')) wo_group
       from (select v1.table_schema,
                    v1.table_name,
                    v1.view_definition,
                    length(v1.view_definition) view_len,
                    sum(case
                          when v2.table_name is not null
                                  then (length(v1.view_definition)
                                          - length(replace(v1.view_definition,
                                                           v2.table_name, '')))
                                         /length(v2.table_name)
                          else 0
                            end) referenced_views
             from information_schema.views v1
                    left outer join information_schema.views v2
                      on v1.table_schema = v2.table_schema
             where v1.table_name <> v2.table_name
             group by v1.table_schema,
                      v1.table_name,
                      v1.view_definition) x
       group by x.table_schema,
		x.table_name) y
 order by 1, 2;
** indexes 
 select t.table_name,
	t.table_rows,
	count(distinct s.index_name) indexes,
	case
          when min(s.unicity) is null then 'N'
          when min(s.unicity) = 0 then 'Y'
          else 'N'
            end unique_index,
	sum(case s.columns
              when 1 then 1
              else 0
		end) single_column,
	sum(case
              when s.columns is null then 0
              when s.columns = 1 then 0
              else 1
		end) multi_column
 from information_schema.tables t
	left outer join (select table_schema,
				table_name,
				index_name,
				max(seq_in_index) columns,
				min(non_unique) unicity
                         from information_schema.statistics
                         where table_schema = schema( )
                         group by table_schema,
                                  table_name,
                                  index_name) s
          on s.table_schema = t.table_schema
               and s.table_name = t.table_name
 where t.table_schema = schema( )
 group by t.table_name,
          t.table_rows
 order by 3, 1;
** copy
 If you want to copy the table structure including its keys, then you should use:

#+BEGIN_SRC sql
 CREATE TABLE `new_table_name` LIKE `old_table_name`;
 #+END_SRC

 #+BEGIN_SRC sql
 CREATE TABLE `new_table_name` SELECT * FROM `old_table_name`;
 #+END_SRC

 #+BEGIN_SRC sql
 (select * from A) except (select * from B) union (select * from B) except select * from A)
 #+END_SRC

** dump
 mysqldump -R --triggers -u root -p culture > file.sql
* TODO Smells
** Booch’s fundamental design principles
*** abstraction
**** Missing Abstraction
 Clumps of data or encoded strings are used instead of creating a class or an interface

 PROBLEMS:
 - it can expose implementation details to different abstractions, violating the principle of encapsulation.
 - When data and associated behavior are spread across abstractions, it can
 lead to tight coupling between entities, resulting in brittle and non-reusable
 code. Hence, not creating necessary abstractions also violates the principle of
 modularization.

 POTENTIAL CAUSES:

 Inadequate design analysis
 When careful thought is not applied during design, it is easy to overlook creating
 abstractions and use primitive type values or strings to “get the work done.” In our
 experience, this often occurs when software is developed under tight deadlines or
 resource constraints.

 Lack of refactoring
 As requirements change, software evolves and entities that were earlier represented
 using strings or primitive types may need to be refactored into classes or interfaces.
 When the existing clumps of data or encoded strings are retained as they are without
 refactoring them, it can lead to a Missing Abstraction smell.

 Misguided focus on minor performance gains
 This smell often results when designers compromise design quality for minor performance gains.
 For instance, we have observed developers using arrays directly in the code
 instead of creating appropriate abstractions since they feel that indexing arrays is faster
 than accessing members in objects. In most contexts, the performance gains due to such
 “optimizations” are minimal, and do not justify the resultant trade-off in design quality.

 https://steemit.com/php/@crell/php-use-associative-arrays-basically-never

 REFACTOR - The refactoring for this smell is to create abstraction(s) that can internally make use
 of primitive type values or strings. For example, if a primitive type value is used as a
 “type-code,” then apply “replace type-code with class”.

 ALIAS:
 Primitive Obsession — This smell occurs when primitive types are used for
 encoding dates, currency, etc. instead of creating classes.

 Data clumps — This smell occurs when there are clumps of data items that
 occur together in lots of places instead of creating a class.
**** Imperative Abstraction
  Consider the case of a large-sized financial application. This application employs
             classes named CreateReport, CopyReport, DisplayReport, etc. to deal with its report
             generation functionality. Each class has exactly one method definition named create,
             copy, display, etc., respectively, and suffers from Imperative Abstraction smell. The
             data items relating to a report such as name of the report, data elements that need to be
             displayed in the report, kind of report, etc. are housed in a “data class” named Report.
             The smell not only increases the number of classes (in this case there are at least
             four classes when ideally one could have been used), but also increases the complex-
             ity involved in development and maintenance because of the unnecessary separation
             of cohesive methods

             Reification
             “Reification” is the promotion or elevation of something that is not an object into an
             object. When we reify behavior, it is possible to store it, pass it, or transform it. Reifica-
             tion improves flexibility of the system at the cost of introducing some complexity [52].
             Many design patterns [54] employ reification. Examples:


             • State pattern: Encoding a state-machine.

             • Command pattern: Encoding requests as command objects. A permitted excep-
             tion for this smell is when a Command pattern has been used to objectify
             method requests.

             • Strategy pattern: Parameterizing a procedure in terms of an operation it uses.

             In other words, when we consciously design in such a way to elevate non-objects
             to objects for better reusability, flexibility, and extensibility (i.e., for improving
             design quality), it is not a smell.


             ALIASES
             “Operation class” [51,52] — This smell occurs when an operation that should
             have been a method within a class has been turned into a class itself.
**** Incomplete Abstraction
 An abstraction (entity or interface) does not support complementary or interrelated methods completely
 For example, if we need to be able to add or remove elements in a data
 structure, the type abstracting that data structure should support both add() and
 remove() methods. Supporting only one of them makes the abstraction incomplete
 and incoherent in the context of those interrelated methods.

  missing “complementary and symmetric” methods,

 Min/max Open/close Create/destroy Get/set
 Read/write Print/scan First/last Begin/end
 Start/stop Lock/unlock Show/hide Up/down
 First/last Push/pull
 Enable/disable  Left/right On/off

 Sometimes, a designer may make a conscious design decision to not provide sym-
 metric or matching methods. For example, in a read-only collection, only add()
 method may be provided without the corresponding remove() method. In such a
 case, the abstraction may appear incomplete, but is not a smell.


 Sometimes, APIs choose to replace symmetrical methods with a method that takes
 a boolean argument (for instance, to enforce a particular naming convention such as
 naming convention that requires accessors to have prefixes “get,” “is,” or
 “set”). For example, classes such as java.awt.MenuItem and java.awt.Component
 originally supported disable() and enable() methods. These methods were dep-
 recated and are now replaced with setEnabled(boolean) method. Similarly, java.
 awt.Component has the method setVisible(boolean) that deprecates the methods
 show() and hide(). One would be tempted to mark these classes as Incomplete
 Abstractions since they lack symmetric methods, i.e., getEnabled() and getVisi-
 ble() respectively. However, since there is no need for corresponding getter methods
 (as these methods take a boolean argument), these classes do not have Incomplete
 Abstraction smell.




 ALIASES
 This smell is also known in literature as:
  
 • “Class supports incomplete behavior” [18]—This smell occurs when the public
 interface of a class is incomplete and does not support all the behavior needed
 by objects of that class.

 • “Half-hearted operations” [63]—This smell occurs when interrelated methods
 provided in an incomplete or in an inconsistent way; this smell could lead to
 runtime problems.
**** Multifaceted Abstraction
 This smell arises when an abstraction has more than one responsibility assigned to it.

 In particular, the Single Responsibility Principle says that an abstraction should have a single
 well-defined responsibility and that responsibility should be entirely encapsulated
 within that abstraction. 

 ALIASES
 This smell is also known in literature as:

 • “Divergent change” [7]—This smell occurs when a class is changed for differ-
 ent reasons.

 • “Conceptualization abuse” [30]—This smell occurs when two or more non-
 cohesive concepts have been packed into a single class of the system.
	 
 • “Large class” [7,24,57,58]—This smell occurs when a class has “too many”
 responsibilities.
	 
 • “Lack of cohesion” [59]—This smell occurs when there is a large type in a
 design with low cohesion, i.e., a “kitchen sink” type that represents many
 abstractions.
**** Unnecessary Abstraction
 An abstraction that is not needed
 ALIASES:
 Irrelevant class - class does not have any meaningful behavior in the design
 Lazy class / Freeloader — class does “too little”
 Small class - class has no (or too few) variables or no (or too few) methods in it
 Mini-class - a public, non-nested class defines less than three methods and less than three attributes (including constants) in it
 No responsibility - class has no responsibility associated with it
 Agent classes - class serve as an “agent” (i.e., they only pass messages from one class to another), indicating that the class may be unnecessary
**** Unutilized Abstraction
 UNUTILIZED ABSTRACTION
 An abstraction is left unused (either not directly used or not
 reachable). This smell manifests in two forms:

 • Unreferenced abstractions—Concrete classes that are not being used by anyone
 • Orphan abstractions—Stand-alone interfaces/abstract classes that do not have
 any derived abstractions


                 This smell violates the principle YAGNI (You
 Aren’t Gonna Need It), which recommends not adding functionality until deemed
 necessary [53]

                 When an abstraction is left unused
 in design, it does not serve a meaningful purpose in design, and hence violates the
 principle of abstraction.

 POTENTIAL CAUSES:
 Leftover garbage during maintenance or refactoring.
 Speculative generality - abstractions are introduced speculating that they may be required sometime in future.


 REFACTORING:
 remove the Unutilized Abstraction from the design.

 IMPACT:
 pollutes the design space and increases cognitive load. This impacts understandability.
 UNUTILIZED ABSTRACTION
 Two or more abstractions have identical names or identical implementation or both


 POTENTIAL CAUSES:

 Copy-paste programming
 The “get-the-work-done” mindset of a programmer leads him to copy and paste code
 instead of applying proper abstraction.
 Ad hoc maintenance
 When the software undergoes haphazard fixes or enhancements over many years, it
 leaves “crufts”6 with lots of redundant code in it.
 Lack of communication
 Often, in industrial software, code duplication occurs because different people work
 on the same code at different times in the life cycle of the software. They are not
 aware of existing classes or methods and end up re-inventing the wheel.

 REFACTORING:
 For identical name form, the suggested refactoring is to rename one of the abstrac-
 tions to a unique name.
 In the case of the identical implementation form of Duplicate Abstraction, if the
 implementations are exactly the same, one of the implementations can be removed.
 If the implementations are slightly different, then the common implementation in
 the duplicate abstractions can be factored out into a common class.


 IMPACT:
 it affects understandability of the design. Developers of client code will be confused and unclear about the choice
 of the abstraction that should be used by their code.

 identical implementation (i.e., they have duplicate code), it becomes difficult to maintain them.
 In summary, this smell indicates a violation of the DRY (Don’t Repeat Yourself)
 principle.
                 If the DRY principle is not fol-
 lowed, a modification of an element within the system requires modifications to other
 logically unrelated elements making maintainability a nightmare. Since there is dupli-
 cation among abstractions in the design, this smell is named Duplicate Abstraction.

 3.7.6 ALIASES
 This smell is also known in literature as:

 •	“Alternative classes with different interfaces” [7]—This smell occurs when
 classes do similar things, but have different names.
 •	“Duplicate design artifacts” [74]—This smell occurs when equivalent design
 artifacts are replicated throughout the architecture.
**** Duplicate Abstraction
 UNUTILIZED ABSTRACTION
 Two or more abstractions have identical names or identical implementation or both


 POTENTIAL CAUSES:

 Copy-paste programming
 The “get-the-work-done” mindset of a programmer leads him to copy and paste code
 instead of applying proper abstraction.
 Ad hoc maintenance
 When the software undergoes haphazard fixes or enhancements over many years, it
 leaves “crufts”6 with lots of redundant code in it.
 Lack of communication
 Often, in industrial software, code duplication occurs because different people work
 on the same code at different times in the life cycle of the software. They are not
 aware of existing classes or methods and end up re-inventing the wheel.

 REFACTORING:
 For identical name form, the suggested refactoring is to rename one of the abstrac-
 tions to a unique name.
 In the case of the identical implementation form of Duplicate Abstraction, if the
 implementations are exactly the same, one of the implementations can be removed.
 If the implementations are slightly different, then the common implementation in
 the duplicate abstractions can be factored out into a common class.


 IMPACT:
 it affects understandability of the design. Developers of client code will be confused and unclear about the choice
 of the abstraction that should be used by their code.

 identical implementation (i.e., they have duplicate code), it becomes difficult to maintain them.
 In summary, this smell indicates a violation of the DRY (Don’t Repeat Yourself)
 principle.
                 If the DRY principle is not fol-
 lowed, a modification of an element within the system requires modifications to other
 logically unrelated elements making maintainability a nightmare. Since there is dupli-
 cation among abstractions in the design, this smell is named Duplicate Abstraction.

 3.7.6 ALIASES
 This smell is also known in literature as:

 •	“Alternative classes with different interfaces” [7]—This smell occurs when
 classes do similar things, but have different names.
 •	“Duplicate design artifacts” [74]—This smell occurs when equivalent design
 artifacts are replicated throughout the architecture.
*** encapsulation
*** modularization
*** hierarchy
** Normal 
*** Alias Duplicates
#+BEGIN_SRC php
use App\Model\Category\Query as CategoryQuery;
use App\Model\Product\Contract\Query as ProductQueryInterface;
use App\Contract\Query as
#+END_SRC
- https://www.tomasvotruba.cz/blog/2019/05/02/alias-as-a-code-smell/
*** Alternative Classes With Different Interfaces
*** Comments
    If you need a comment to explain what a block of code does, try Extract Function (106). If the method is already extracted but you still need a comment to explain what it does, use Change Function Declaration (124) to rename it. If you need to state some rules about the required state of the system, use Introduce Assertion (302).
*** Data Class
*** Data Clumps
    Fix: Use Extract Class (182) on the fields to turn the clumps into an object.
*** Divergent Change			
    Within Classes
*** Duplicated Code 	
    Within Classes
    Same code structure in more than one place
    Don't Repeat Yourself (DRY)
**** Same expression in different places 
     The simplest duplicated code problem is when you have the same expression in two
     methods of the same class. Then all you have to do is Extract Function and invoke the code from both places.
     
*** Feature Envy	
    Between Classes	A method accesses the data of another object more than its own data
*** Global Data
    "Global data is especially nasty when it’s mutable. Global data that you can guarantee
    never changes after the program starts is relatively safe—if you have a language that can
    enforce that guarantee."
    Fix: Encapsulate Variable
*** Insider Trading
*** Large Class		
    Within Classes	
    A class contains too many fields, methods, lines of code.
    Fix: Extract Class, Extract Superclass, Replace Type Code with Subclass
*** Lazy Element
    It may be a function that’s named the same as its body code reads, or a class that is essentially one simple function.
    Fix: Inline Function, Inline Class, Collapse Hierarchy
*** Long Function	
    Within Classes
    Fix: Extract Function
*** Long Parameter List			
    Within Classes
    Fix: Replace Parameter with Query, Preserve Whole Object, INtroduce PArameter Object, Remove Flag Argument, Combine Functions into Class
*** Loops
    Fix: Replace Loop with Pipeline
*** Message Chains
    You see message chains when a client asks one object for another object, which the client then asks for yet another object, which the client then asks for yet another another object, and so on.
95 
*** Middle Man
    Fix: Remove Middle Man, Inline Function, Replace Superclass with Delegate, Replace Subclass with Delegate
*** Mysterious Name
    Fix: Change Function Declaration, Rename Variable, Rename Field
*** Primitive Obsession
    Primitive types: integers, floating point numbers and strings. Money, coordinates or ranges.
    Fix: Replace Primitive with Object
*** Refused Bequest
*** Repeated Switches
*** Shotgun Surgery
*** Speculative Generality
    “Oh, I think we’ll need the ability to do this kind of thing someday”
*** Temporary Field
* Codebases
| Name                              | Lines of Code | Description                                                                                   | Tutorials                       |
|-----------------------------------+---------------+-----------------------------------------------------------------------------------------------+---------------------------------|
| [[https://github.com/adamculp/refactoring101][Video Rental Shop]]                 |           132 | From Martin Fowler book "Refactoring: Improving the Design of Existing Code" converted to PHP | [[https://youtu.be/0DYIJdX6kB4][Refactoring 101]]                 |
| [[https://github.com/jbrains/trivia/tree/master/php][Legacy Code Retreat - Trivia Game]] |           196 | Designed for [[https://legacycoderetreat.typepad.com/][Legacy Code Retreat]] events                                                       | [[https://code.tutsplus.com/series/refactoring-legacy-code--cms-633][Refactoring Legacy Code]]         |
|                                   |               |                                                                                               | [[https://code.tutsplus.com/courses/techniques-for-refactoring-code][Techniques for Refactoring Code]] |
|                                   |               |                                                                                               | [[http://blog.adrianbolboaca.ro/2014/04/legacy-coderetreat/#sessions][Legacy Coderetreat (Java)]]       |

** [[https://github.com/adamculp/refactoring101][Video Rental Shop]]
   phploc
Size
  Lines of Code (LOC)                              132
  Comment Lines of Code (CLOC)                      12 (9.09%)
  Non-Comment Lines of Code (NCLOC)                120 (90.91%)
  Logical Lines of Code (LLOC)                      48 (36.36%)
    Classes                                         40 (83.33%)
      Average Class Length                          13
        Minimum Class Length                         6
        Maximum Class Length                        24
      Average Method Length                          2
        Minimum Method Length                        1
        Maximum Method Length                       19
    Functions                                        0 (0.00%)
      Average Function Length                        0
    Not in classes or functions                      8 (16.67%)

Structure
  Namespaces                                         0
  Interfaces                                         0
  Traits                                             0
  Classes                                            3
    Abstract Classes                                 0 (0.00%)
    Concrete Classes                                 3 (100.00%)
  Methods                                           11
    Scope
      Non-Static Methods                            11 (100.00%)
      Static Methods                                 0 (0.00%)
    Visibility
      Public Methods                                11 (100.00%)
      Non-Public Methods                             0 (0.00%)
  Functions                                          0
    Named Functions                                  0 (0.00%)
    Anonymous Functions                              0 (0.00%)
  Constants                                          3
    Global Constants                                 0 (0.00%)
    Class Constants                                  3 (100.00%)

Cyclomatic Complexity
  Average Complexity per LLOC                     0.17
  Average Complexity per Class                    3.67
    Minimum Class Complexity                      1.00
    Maximum Class Complexity                      9.00
  Average Complexity per Method                   1.73
    Minimum Method Complexity                     1.00
    Maximum Method Complexity                     9.00

Dependencies
  Global Accesses                                    0
    Global Constants                                 0 (0.00%)
    Global Variables                                 0 (0.00%)
    Super-Global Variables                           0 (0.00%)
  Attribute Accesses                                15
    Non-Static                                      15 (100.00%)
    Static                                           0 (0.00%)
  Method Calls                                      14
    Non-Static                                      14 (100.00%)
    Static                                           0 (0.00%)
** [[https://github.com/jbrains/trivia/tree/master/php][Legacy Code Retreat - Trivia Game]]
   phploc
Size
  Lines of Code (LOC)                              196
  Comment Lines of Code (CLOC)                       0 (0.00%)
  Non-Comment Lines of Code (NCLOC)                196 (100.00%)
  Logical Lines of Code (LLOC)                      99 (50.51%)
    Classes                                         88 (88.89%)
      Average Class Length                          88
        Minimum Class Length                        88
        Maximum Class Length                        88
      Average Method Length                          7
        Minimum Method Length                        1
        Maximum Method Length                       17
    Functions                                        1 (1.01%)
      Average Function Length                        1
    Not in classes or functions                     10 (10.10%)

Cyclomatic Complexity
  Average Complexity per LLOC                     0.26
  Average Complexity per Class                   25.00
    Minimum Class Complexity                     25.00
    Maximum Class Complexity                     25.00
  Average Complexity per Method                   3.18
    Minimum Method Complexity                     1.00
    Maximum Method Complexity                    10.00

Dependencies
  Global Accesses                                    0
    Global Constants                                 0 (0.00%)
    Global Variables                                 0 (0.00%)
    Super-Global Variables                           0 (0.00%)
  Attribute Accesses                               115
    Non-Static                                     115 (100.00%)
    Static                                           0 (0.00%)
  Method Calls                                      21
    Non-Static                                      21 (100.00%)
    Static                                           0 (0.00%)

Structure
  Namespaces                                         0
  Interfaces                                         0
  Traits                                             0
  Classes                                            1
    Abstract Classes                                 0 (0.00%)
    Concrete Classes                                 1 (100.00%)
  Methods                                           11
    Scope
      Non-Static Methods                            11 (100.00%)
      Static Methods                                 0 (0.00%)
    Visibility
      Public Methods                                11 (100.00%)
      Non-Public Methods                             0 (0.00%)
  Functions                                          1
    Named Functions                                  1 (100.00%)
    Anonymous Functions                              0 (0.00%)
  Constants                                          0
    Global Constants                                 0 (0.00%)
    Class Constants                                  0 (0.00%)
* Definitions
** Anemic Domain Model
- focus on data
- structured
- easy to implement and to maintain
- contains little or no logic
- no guarantee to be valid or consisten
*** use
    - prototyping
    - easy of use
    - easily generated 
** Rich Domain Model
- combines data and logic 
- valid by design
- easy to test
- defined state transistions
*** use
    - clean code 
    - testability
    - truly OOP
** Characterization Test
   Test that characterizes the actual behavior of a piece of code. It acts as a change detector, protecting legacy code from unintended changes.
** Polymorphism
   describes a pattern in object oriented programming in which classes have different functionality while sharing a common interface.
** Parameter vs. Argument
   A parameter is the variable which is part of the method’s signature (method declaration). An argument is an expression used when calling the method.

Consider the following code:

void Foo(int i, float f)
{
// Do things
}

void Bar()
{
int anInt = 1;
Foo(anInt, 2.0);
}

Here i and f are the parameters, and anInt and 2.0 are the arguments.

https://stackoverflow.com/questions/1788923/parameter-vs-argument
** Principle vs. Practices
   - The Boy scout motto – “Be prepared”–is a timeless principle. “Buy a plunger before you need a plunger” is a practice that applies this principle in a memorable way.
   - Principles are good ideas or good values stated in a context-independent manner. Practices are applications of theses principles stated in a context-dependent way.
   - Principle: a fundamental, primary or general law or truth
   - Practice: the action or process of performing or doing something
** Logical operators  
They are used for different purposes and in fact have different operator precedences. The && and || operators are intended for Boolean conditions, whereas and and or are intended for control flow.

For example, the following is a Boolean condition:

if ($foo == $bar && $baz != $quxx) {

This differs from control flow:

doSomething() or die();
** Value Object
- measures, quantifies or describe a thing in the domain
- identity is based on composition of values
- immutable
- compared using all values
- no side effects
** Service
   an object that dose work
** Technical Dept
   is the debt that accumulate when you knowingly or unknowingly make
   wrong or non-optimal design decisions.

 http://blog.insight.sensiolabs.com/2014/11/04/technical-debt-relevant-projects.html
* Practices
** Always Use 'declare(stric_types=1)'
#+BEGIN_SRC php
declare(stric_types=1);

$var  = '0';
if ( !$var ) {
   echo 'negation';
}
#+END_SRC

#+RESULTS:
: negation
** Avoid Else, Return Early (Guard Clause)
   Return as soon as you know your method cannot do any more meaningful work.
#+BEGIN_SRC php
 public function foo(int $x): string
    {
        $result = null;

        if ($x === 1) {
            $result = 'a';
        } elseif ($x === 2) {
            $result = 'b';
        } else {
            $result = 'c';
        }

        return $result;
    }
#+END_SRC
#+BEGIN_SRC php
 public function foo(int $x): string
    {
        if ($x === 1) {
            return 'a';
        }

        if ($x === 2) {
            return 'b';
        }

        if ($x === 3) {
            return 'c';
        }
    }
#+END_SRC

Refactoring: Replace Nested Conditional with Guard Clauses
Guard clause provides an early exit from a subroutine. Removing one level of nesting and resulting in flatter code.
   
https://stackoverflow.com/questions/4838828/why-should-a-function-have-only-one-exit-point
** Avoid Negative Conditionals
   It is much easier, for the human mind, to comprehend positive reasoning. So if you can avoid negative conditionals, you should always take that path.
#+BEGIN_SRC php
if (!count){
...
}
#+END_SRC

#+BEGIN_SRC php
if (count == 0){
...
}
#+END_SRC
** Don't Use 'clone'
*** https://dcsg.me/articles/dont-clone-your-php-objects-deepcopy-them/
*** TODO show example with Doctrine
** Don't Use 'else if'
   Else if is not compatible with the colon syntax for if|elseif blocks. For this reason, use elseif for conditionals
#+BEGIN_SRC php
<?php if ($user) { ?>
    <span>OK. Your registration is successful</span>
<?php } else { ?>
    <span>Something went wrong! Please try again later! </span>
<?php } ?>
#+END_SRC

#+BEGIN_SRC php
 if ($user) : ?>
    <div>OK. Your registration is successful</div>
<?php else : ?>
    <div>Something went wr+ong! Please try again later!</div>
<?php endif ?>
#+END_SRC

Most of the time the alternative (endif) syntax is used in view scripts. It's often hard to see/notice the end of an if statement since a curly brace only takes up one character, when you're at the bottom of a file, it's hard to tell if it's the end of an if or a foreach. For example:

#+BEGIN_SRC php
<?php if ($condition): ?>

    <div>a huge block of html</div>

<?php endif; ?>
#+END_SRC


https://www.mediawiki.org/wiki/Manual:Coding_conventions/PHP
And the latter has poorer performance.
#+BEGIN_SRC php
// This:
if ( $foo == 'bar' ) {
	echo 'Hello world';
} else if ( $foo == 'Bar' ) {
	echo 'Hello world';
} else if ( $baz == $foo ) {
	echo 'Hello baz';
} else {
	echo 'Eh?';
}

// Is actually equivalent to:
if ( $foo == 'bar' ) {
	echo 'Hello world';
} else {
	if ( $foo == 'Bar' ) {
		echo 'Hello world';
	} else {
		if ( $baz == $foo ) {
			echo 'Hello baz';
		} else {
			echo 'Eh?';
		}
	}
}
#+END_SRC
** Don't Use Globals
   EVIL in pure form ;)
** Don't Use Magic Numbers
   Raw numbers in code. Like 86400 - that's a number of seconds per day. But it is not so obvious for every one whats that number means
Refactoring: Replace Magic Number with Symbolic Constant
** Don't Use Method Chaining Syntax
   Violating CQS
** Don't Use Optional Dependencies
   Use Constructor Injection not Setter Injection. Constructor Injection gives you a valid object with all its dependencies, upon construction.
** Don't Use Switch Parameter
   A method runs different code depending on the values of an parameter
   Refactoring: Replace Parameter with Method
** Don't Use Traits
   Further Reading: https://dev.to/barryosull/why-i-dont-like-traits
** fully-qualified class name (FQCN)
** Eliminate or Reduce Number of Comments
** Eliminate or Reduce Number of Parameters
   Functions should have a small number of arguments. No argument is best, followed by one, two, and three. More than three is very questionable and should be avoided with prejudice.
** Eliminate or Reduce Number of Setters
   Further Reading: https://beberlei.de/2012/08/22/building_an_object_model__no_setters_allowed.html 
http://williamdurand.fr/2013/06/03/object-calisthenics/#9-no-getterssettersproperties
** Make Class Constants & Variables Always Private
** Make Classes Always Final
   Force to use composition over inheritance principle
   Further Reading: https://ocramius.github.io/blog/when-to-declare-classes-final https://matthiasnoback.nl/2018/09/final-classes-by-default-why/
** Sprout Class
** Sprout Method
   When adding new functionality, write the code in a new method with TDD and then call this method from the old code. So even if you can’t test the code where your method is being called, at least the new code has tests.
1. Identify where you need to make your code change.
2. If the change can be formulated as a single sequence of statements in one place in a method, write down a call for a new method that will do the work involved and then comment it out. (I like to do this before I even write the method so that I can get a sense of what the method call will look like in context.) 
3. Determine what local variables you need from the source method, and make them arguments to the call. 
4.Determine whether the sprouted method will need to return values to source method. If so, change the call so that its return value is assigned to a variable. 
5. Develop the sprout method using test-driven development. 
6. Remove the comment in the source method to enable the call.
** Use parentheses
   Parentheses help clarify the order of operators...etc. PHP won’t get confused if you don’t use parentheses because it knows the order of operators table very well. However, a person looking at your program has to figure out which is done first, and parentheses help group operations together.
#+BEGIN_SRC php
if (age < 20 || sales < 1200 && hrsWorked > 15) {}
#+END_SRC

#+BEGIN_SRC php
if ((age < 20) || ((sales < 1200) && (hrsWorked > 15))) {}
#+END_SRC
** Wrap Class
   Choosing to use Wrap Class is a whole other issue. There is a higher thresh- old for this pattern. Generally two cases tip me toward using Wrap Class: 1. The behavior that I want to add is completely independent, and I don’t want to pollute the existing class with behavior that is low level or unre- lated. 2. The class has grown so large that I really can’t stand to make it worse. In a case like this, I wrap just to put a stake in the ground and provide a roadmap for later changes.
** Wrap Method
** Naming
*** variable
*** method
   - isX() or hasX() for bool return type
* Principles
** SOLID
   There is a strong relationship beetween each of those principles. If you take each of those principles in isolation and try to apply them in your codebase you will get limited benefit out of that. it's only when you take enterly package apply it in it entarity. Applying it all at once. Strong sinergy efect.
*** Single Responsibilty (SRP)
    A class should have only one reason to change - doing one thing, and do it well The object should be able to do the job completely The class has only one well-defined responsibility which is exclusively handling user data. No more, no less.
*** Open/Closed Principle (OCP)
    Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. Interface is open for extension but closed for modification.
*** Liskov Substitution (LSP)
    Metody do klas bazowych, muszą być w stanie używać również obiektów klas dziedziczących po klasach bazowych.	Program to an, interface, not an implementation.
*** Interface Segregation (ISP)
    A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use.
*** Dependency Inversion (DIP)
    Depend on abstractions, not concretions	Program to an, interface, not an implementation.
** Design
*** Separation of Concerns (SoC)
    The no.1 - the most important
**** opposite
     Big Ball of Mud
*** Big Ball of Mud
*** Command Query Separation (CQS)
*** Composition Over Inheritance	
*** YAGNI
*** Don't Repeat Yourself (DRY)
    http://web-techno.net/dry-principle-explained/
*** The Law of Demeter (LoD)
    Each unit should only talk to its friends; don't talk to strangers.	
    - Object Calisthenics - One Arrow Per Line
** Architectural
*** Model-View-Controller
    • The Model: Captures and centralizes all the domain model behaviour. This layer manages all the data, logic and business rules independently of the data representation. It can be said that the Model layer is the heart and soul of every MVC application. • The Controller: Orchestrates interactions between the other layers. Triggers actions on the model in order to update its state and refreshes the representations associated to the model. Additionally, the Controller can also send messages to the View layer in order to change the specific Model representation. • The View: A layer whose main purpose is to expose the differing representations of the Model layer and to give a way to trigger changes on the Model’s state.
* TODO PSR
Name	PSR	Community	Description
Method names	camelCase() 21/22. lower_under 1/22	camelCase()	Based on an eye tracking study on camelCase and snake_case (PDF) from 2010, snake_case is 20% easier to read than camelCase!
Properties names	$StudlyCaps or $camelCase or $under_score	$camelCase XMLHttpRequest is still a great tragedy
* TODO Patterns
  Patterns are formalized best practices.
** Software design patterns
*** Creational
    Creation of objects themselves - separate the construction of a complex object from its representation

**** Factory
     Separating the creation of an object from the actual implementation.
     If creating the object is a complicated job you can do all of the work in the factory, instead of repeating it every time you want to create a new instance.
***** Simple Factory
#+BEGIN_SRC php
class Bicycle
{
}

class SimpleFactory
{
    public function createBicycle(): Bicycle
    {
        return new Bicycle();
    }
}      
#+END_SRC

#+BEGIN_SRC php
class SimpleFactoryTest extends TestCase
{
    public function testCanCreateBicycle()
    {
        $bicycle = (new SimpleFactory())->createBicycle();
        $this->assertInstanceOf(Bicycle::class, $bicycle);
    }
}
#+END_SRC
***** Method Factory
#+BEGIN_SRC php
interface CarFactory 
{
    public function makeCar();
}

interface Car 
{
    public function getType();
}

class SedanFactory implements CarFactory 
{
    public function makeCar() 
    {
        return new Sedan();
    }
}

class Sedan implements Car 
{
    public function getType() 
    {
        return 'Sedan';
    }
}

/* Client */
$factory = new SedanFactory();
$car = $factory->makeCar();
#+END_SRC
***** Abstract Factory
***** Links
     - [[https://stackify.com/static-factory-methods/][Abstract Factory Cleaner Code with Static Factory Methods]]      
**** Builder
#+BEGIN_SRC php
class Car
{
    ...
}

class CarBuilder
{
    public function __construct()
    {
        $car = new Car;
    }
    
    public function build(): Car
    {
        return $car;   
    }

    public function setSeats(int $seats)
    {
        $car->setSeats($seats);
    }
}
#+END_SRC
***** links
      - http://blog.codeleak.pl/2014/06/test-data-builders-and-object-mother.html
      - https://davedevelopment.co.uk/2015/01/28/test-data-builders.html
**** Prototype
#+BEGIN_SRC php
abstract class Prototype{
    protected $name;
 
    public function __construct($name) {
        $this->name=$name;
    }
    abstract function __clone();
    public function getName() {
        return $this->name;
    }
}
 
class ConcretePrototype extends Prototype{
 
    public function __construct($name) {
        parent::__construct($name);
    }
    public function __clone() {}
}
 
// testy
$prototype = new ConcretePrototype("nazwa");
echo  $prototype->getName(); // wyswietli "nazwa"
$prototype2 = clone $prototype;
echo  $prototype2->getName(); // wyswietli "nazwa"

#+END_SRC
**** Dependency Injection
     A class receives its dependencies from external sources rather than creating them itself. That is, following the Dependency Inversion principle.
***** Types of injection:
****** Construction injection: 
       dependencies are injected when creating the object. It can be used for required and optional dependencies.
****** Setter injection: 
       dependencies are injected through setters, and they are always optional.
****** Property injection: 
       dependencies are injected directly through public properties. This type of injection is not recommended as there is no control at all of what is being injected.
***** Links
      - [[https://www.sitepoint.com/php-dependency-injection-container-performance-benchmarks/][PHP Dependency Injection Container Performance Benchmarks]]
*** Structural
    They act as interconnectors between entities. It serves as a blueprint for how basic classes can be combined to form bigger  entities. Structural patterns describe the static architecture of a design;

**** Bridge
  The Bridge pattern can be quite straightforward; it effectively allows us to decouple an abstraction from an implementation so the two can vary independently.
#+BEGIN_SRC php
interface FormatterInterface
{
    public function format(string $text);
}

class PlainTextFormatter implements FormatterInterface
{
    public function format(string $text)
    {
        return $text;
    }
}

class HtmlFormatter implements FormatterInterface
{
    public function format(string $text)
    {
        return sprintf('<p>%s</p>', $text);
    }
}

abstract class Service
{
    /**
     * @var FormatterInterface
     */
    protected $implementation;

    /**
     * @param FormatterInterface $printer
     */
    public function __construct(FormatterInterface $printer)
    {
        $this->implementation = $printer;
    }

    /**
     * @param FormatterInterface $printer
     */
    public function setImplementation(FormatterInterface $printer)
    {
        $this->implementation = $printer;
    }

    abstract public function get();
}

class HelloWorldService extends Service
{
    public function get()
    {
        return $this->implementation->format('Hello World');
    }
}

class BridgeTest extends TestCase
{
    public function testCanPrintUsingThePlainTextPrinter()
    {
        $service = new HelloWorldService(new PlainTextFormatter());
        $this->assertEquals('Hello World', $service->get());

        // now change the implementation and use the HtmlFormatter instead
        $service->setImplementation(new HtmlFormatter());
        $this->assertEquals('<p>Hello World</p>', $service->get());
    }
}
#+END_SRC
**** Facade
- A Facade is meant to decouple a client and a sub-system by embedding many (but sometimes just one) interface, and of course to reduce complexity.
- That’s why a good facade has no new in it. If there are multiple creations for each method, it is not a Facade, it’s a Builder or a [Abstract|Static|Simple] Factory [Method].
- The best facade has no new and a constructor with interface-type-hinted parameters. If you need creation of new instances, use a Factory as argument.
- A Facade design pattern works providing a single class that in itself instantiates other classes and provides a simple interface to use those functions. A warning when using such pattern is that, as classes are instantiated within the Facade, you are essentially tightly coupling the classes that it utilizes. There are cases where you want this, but there are cases where you do not. Where do you do not want this behavior, you are better suited to using dependency injection. I have found this to be useful when wrapping a set of poor APIs into a single unified API. It reduces external dependencies, allowing complexity to be internalized; this process can make your code more readable. In other situations, where the various classes were loosely coupled together, we may find it better to use dependency injection. By injecting objects that perform various actions into the ToyFactory class we can benefit from making testing easier by being able to inject fake classes that the ToyFactory class can manipulate. Personally, I am a huge believer in making code as easily testable as possible; hence why I don't like this approach.

#+BEGIN_SRC php
class Facade
{
    /**
     * @var OsInterface
     */
    private $os;

    /**
     * @var BiosInterface
     */
    private $bios;

    /**
     * @param BiosInterface $bios
     * @param OsInterface   $os
     */
    public function __construct(BiosInterface $bios, OsInterface $os)
    {
        $this->bios = $bios;
        $this->os = $os;
    }

    public function turnOn()
    {
        $this->bios->execute();
        $this->bios->waitForKeyPress();
        $this->bios->launch($this->os);
    }

    public function turnOff()
    {
        $this->os->halt();
        $this->bios->powerDown();
    }
}

interface OsInterface
{
    public function halt();

    public function getName(): string;
}

interface BiosInterface
{
    public function execute();

    public function waitForKeyPress();

    public function launch(OsInterface $os);

    public function powerDown();
}

class FacadeTest extends TestCase
{
    public function testComputerOn()
    {
        /** @var OsInterface|\PHPUnit_Framework_MockObject_MockObject $os */
        $os = $this->createMock('DesignPatterns\Structural\Facade\OsInterface');

        $os->method('getName')
            ->will($this->returnValue('Linux'));

        $bios = $this->getMockBuilder('DesignPatterns\Structural\Facade\BiosInterface')
            ->setMethods(['launch', 'execute', 'waitForKeyPress'])
            ->disableAutoload()
            ->getMock();

        $bios->expects($this->once())
            ->method('launch')
            ->with($os);

        $facade = new Facade($bios, $os);

        // the facade interface is simple
        $facade->turnOn();

        // but you can also access the underlying components
        $this->assertEquals('Linux', $os->getName());
    }
}

#+END_SRC
**** Composite
To treat a group of objects the same way as a single instance of the object.


Composite Imagine an audio system consisting of individual songs and also playlists of songs. Yes, playlists consist of songs, but we want both to be treated individually. Both are types of music, both can be played. The Composite design pattern can help here; it allows us to ignore the differences between compositions of objects and individual objects. It allows us to treat both with identical or nearly-identical code. Let's put together a little example; a song is our example of a leaf, with playlists being composites. Music is our abstraction of playlists and songs; therefore, we can call this our component. The client of all this is our index.php file. By not discriminating between leaf-nodes and branches, our code becomes less complex and therefore less error prone.

#+BEGIN_SRC php
interface RenderableInterface
{
    public function render(): string;
}

/**
 * The composite node MUST extend the component contract. This is mandatory for building
 * a tree of components.
 */
class Form implements RenderableInterface
{
    /**
     * @var RenderableInterface[]
     */
    private $elements;

    /**
     * runs through all elements and calls render() on them, then returns the complete representation
     * of the form.
     *
     * from the outside, one will not see this and the form will act like a single object instance
     *
     * @return string
     */
    public function render(): string
    {
        $formCode = '<form>';

        foreach ($this->elements as $element) {
            $formCode .= $element->render();
        }

        $formCode .= '</form>';

        return $formCode;
    }

    /**
     * @param RenderableInterface $element
     */
    public function addElement(RenderableInterface $element)
    {
        $this->elements[] = $element;
    }
}

class InputElement implements RenderableInterface
{
    public function render(): string
    {
        return '<input type="text" />';
    }
}

class TextElement implements RenderableInterface
{
    /**
     * @var string
     */
    private $text;

    public function __construct(string $text)
    {
        $this->text = $text;
    }

    public function render(): string
    {
        return $this->text;
    }
}

class CompositeTest extends TestCase
{
    public function testRender()
    {
        $form = new Composite\Form();
        $form->addElement(new Composite\TextElement('Email:'));
        $form->addElement(new Composite\InputElement());
        $embed = new Composite\Form();
        $embed->addElement(new Composite\TextElement('Password:'));
        $embed->addElement(new Composite\InputElement());
        $form->addElement($embed);

        // This is just an example, in a real world scenario it is important to remember that web browsers do not
        // currently support nested forms

        $this->assertEquals(
            '<form>Email:<input type="text" /><form>Password:<input type="text" /></form></form>',
            $form->render()
        );
    }
}
#+END_SRC
**** Adapter (Wrapper)
#+BEGIN_SRC php
// Concrete Implementation of PayPal Class
class PayPal {
     
    public function __construct() {
        // Your Code here //
    }
     
    public function sendPayment($amount) {
        // Paying via Paypal //
        echo "Paying via PayPal: ". $amount;
    }
}
 
// Simple Interface for each Adapter we create
interface paymentAdapter {
    public function pay($amount);
}
 
class paypalAdapter implements paymentAdapter {
     
    private $paypal;
 
    public function __construct(PayPal $paypal) {
        $this->paypal = $paypal;
    }
     
    public function pay($amount) {
        $this->paypal->sendPayment($amount);
    }
}

// Client Code
$paypal = new paypalAdapter(new PayPal());
$paypal->pay('2629');
#+END_SRC

   getData and
  setData (not as “pretty”).
**** Decorator
Adding new behaviors to objects dynamically by placing them inside special wrapper objects.
#+BEGIN_SRC php
class eMailBody 
{
    private $header = 'This is email header';
    private $footer = 'This is email Footer';
    public $body = '';
 
    public function loadBody() 
    {
        $this->body .= "This is Main Email body.<br />";
    }

    class christmasEmail extends eMailBody 
    {
        public function loadBody() {
            parent::loadBody();
            $this->body .= "Added Content for Xmas<br />";
        }
    }
 
    $christmasEmail = new christmasEmail();
    $christmasEmail->loadBody();
    echo $christmasEmail->body;
#+END_SRC
*** Behavioral
    They work to explain how objects interact with each other; how they can send messages between each of the objects and how you can divide the steps of various tasks up among classes. Describe a flowing process.

**** Chain Of Responsibility
  Is an object oriented version of the if ... else if ... else if ....... else ... endif idiom

#+BEGIN_SRC php
interface PurchaserInterface
{
    public function setNextPurchaser(PurchaserInterface $nextPurchaser): void;

    public function buy($price): void;
}

final class AssociatePurchaser implements PurchaserInterface
{
    /**
     ,* @var PurchaserInterface
     ,*/
    private $nextPurchaser;

    public function setNextPurchaser(PurchaserInterface $nextPurchaser): void
    {
        $this->nextPurchaser = $nextPurchaser;
    }

    public function buy($price): void
    {
        if ($price < 100) {
            echo('Associate purchased');
            return;
        }

        if ($this->nextPurchaser) {
            $this->nextPurchaser->buy($price);
            return;
        }

        echo 'Associate could not buy';
    }
}

final class ManagerPurchaser implements PurchaserInterface
{
    /**
     ,* @var PurchaserInterface
     ,*/
    private $nextPurchaser;

    public function setNextPurchaser(PurchaserInterface $nextPurchaser): void
    {
        $this->nextPurchaser = $nextPurchaser;
    }

    public function buy($price): void
    {
        if ($price < 200) {
            echo('Manager purchased');
            return;
        }

        if($this->nextPurchaser) {
            $this->nextPurchaser->buy($price);
            return;
        }

        echo 'Manager could not buy';
    }
}

final class DirectorPurchaser implements PurchaserInterface
{
    /**
     ,* @var PurchaserInterface
     ,*/
    private $nextPurchaser;

    public function setNextPurchaser(PurchaserInterface $nextPurchaser): void
    {
        $this->nextPurchaser = $nextPurchaser;
    }

    public function buy($price): void
    {
        if ($price < 300) {
            echo('Director purchased');
            return;
        }

        if($this->nextPurchaser) {
            $this->nextPurchaser->buy($price);
            return;
        }

        echo 'Director could not buy';
    }
}

class ChainOfResponsibilityTest extends TestCase
{
    public function testOne()
    {
        $this->expectOutputString('Director purchased');

        $associate = new AssociatePurchaser();
        $manager = new ManagerPurchaser();
        $director = new DirectorPurchaser();
        $associate->setNextPurchaser($manager);
        $manager->setNextPurchaser($director);

        $associate->buy(299);
    }
}

#+END_SRC
**** Observer
The Observer design pattern essentially allows an object (the subject) to maintain a list of observers that are automatically notified when the state of the that object changes. This pattern applies a one-to-many dependency between objects; there is always one subject that updates many observers. This pattern applies a one-to-many dependency between objects; there is always one subject that updates many observers.
#+BEGIN_SRC php
class User implements \SplSubject
{
    /**
     * @var string
     */
    private $email;

    /**
     * @var \SplObjectStorage
     */
    private $observers;

    public function __construct()
    {
        $this->observers = new \SplObjectStorage();
    }

    public function attach(\SplObserver $observer)
    {
        $this->observers->attach($observer);
    }

    public function detach(\SplObserver $observer)
    {
        $this->observers->detach($observer);
    }

    public function changeEmail(string $email)
    {
        $this->email = $email;
        $this->notify();
    }

    public function notify()
    {
        /** @var \SplObserver $observer */
        foreach ($this->observers as $observer) {
            $observer->update($this);
        }
    }
}

class UserObserver implements \SplObserver
{
    /**
     * @var User[]
     */
    private $changedUsers = [];

    /**
     * It is called by the Subject, usually by SplSubject::notify()
     *
     * @param \SplSubject $subject
     */
    public function update(\SplSubject $subject)
    {
        $this->changedUsers[] = clone $subject;
    }

    /**
     * @return User[]
     */
    public function getChangedUsers(): array
    {
        return $this->changedUsers;
    }
}

class ObserverTest extends TestCase
{
    public function testChangeInUserLeadsToUserObserverBeingNotified()
    {
        $observer = new UserObserver();

        $user = new User();
        $user->attach($observer);

        $user->changeEmail('foo@bar.com');
        $this->assertCount(1, $observer->getChangedUsers());
    }
}
#+END_SRC
**** Strategy
Allow us to alter the behavior of an object at runtime.
We defined a family of algorithms, bound by one common interface
These algorithms are interchangeable; they can be swapped in and out without affecting the client implementation
We encapsulated each algorithm within a class                

#+BEGIN_SRC php
class Customer
{
    /**
     * @var float
     */
    private $bill;

    /**
     * @var BillingStrategyInterface
     */
    private $strategy;

    public function __construct(BillingStrategyInterface $strategy)
    {
        $this->strategy = $strategy;
    }

    public function setStrategy(BillingStrategyInterface $strategy)
    {
        $this->strategy = $strategy;
    }

    public function addBeer(float $price): void
    {
        $this->bill += $this->strategy->getPrice($price);
    }

    public function printBill(): void
    {
        echo "Total: $this->bill";
    }
}

interface BillingStrategyInterface
{
    public function getPrice(float $rawPrice): float;
}

class NormalStrategy implements BillingStrategyInterface
{
    public function getPrice(float $rawPrice): float
    {
        return $rawPrice;
    }
}

class HappyHourStrategy implements BillingStrategyInterface
{
    public function getPrice(float $rawPrice): float
    {
        return $rawPrice * 0.5;
    }
}

class StrategyTest extends TestCase
{
    public function testOne()
    {
        $this->expectOutputString('Total: 15');

        //Normal billing
        $customer = new Customer(new NormalStrategy());
        $customer->addBeer(10);

        //Start Happy Hour
        $customer->setStrategy(new HappyHourStrategy());
        $customer->addBeer(10);

        $customer->printBill();
    }
}
#+END_SRC
**** Command 
     Command objects encapsulate an action and its parameters. We have an Invoker and a Receiver
**** Iterator 
     Iterators are used to access the elements of an aggregate object sequentially without exposing its underlying representation
**** Null Object
      Designed to act as a default value of an object
**** Template method:
     Describes the program skeleton of a program
*** Concurrency

** Architectural patterns
   This is not strictly a design pattern (but the Gang of Four didn't cover Architectural patterns
in their book); but it is incredibly relevant for PHP developers due to the web-oriented
nature of PHP. Architectural patterns address various different constraints in computer
systems through addressing performance limitations, high availability, and also
minimization of business risk.
Most developers will be familiar with the Model-View-Controller architecture when it
comes to web frameworks, more recently other architectures have started to emerge; for
example, a microservices architecture works by a set of RESTful APIs that are independent
and interconnected. Some people believe microservices move problems from the software
development layer to the systems architecture layer. The opposite of microservices often
referred to as a monolithic architecture, is where all the code is together in one application.
*** Active Record
Problem: Accessing data in a database
prevent duplication & centralize access
don't have to add any properties to class, just add new column to table
objects are tightly coupled to the database schema - hard to test without actually using database
breaking SOLID's Single Responsibility Principle - object is responsible for knowing how to create, retrieve, update and delete database entry
                    

<?php declare(strict_types=1);

class User
{

    /**
     * @var int
     */
    private $id;

    /**
     * @var string
     */
    private $name;

    public function getId(): int
    {
        return $this->id;
    }

    public function setId(int $id)
    {
        $this->id = $id;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function setName(string $name)
    {
        $this->name = $name;
    }

}

$id = 1;
$pdo = new PDO('sqlite:test.db');
$sth = $pdo->prepare("SELECT * FROM user WHERE id =:id");
$sth->bindParam(":id", $id, PDO::PARAM_INT);
$sth->execute();
$row = $sth->fetch(PDO::FETCH_ASSOC);
$user = new User();
$user->SetId((int) $row['id']);
$user->SetName($row['name']);
                    

                
cons: hardcoded columns name, every time we add new column to database we have to manually add it in code in multiple places, hard to maintain,
                    

<?php declare(strict_types=1);

class User
{
    private $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function load(int $id)
    {
        $sth = $this->pdo->prepare("SELECT * FROM user WHERE id =:id");

        $sth->bindParam(":id", $id, PDO::PARAM_INT);
        $sth->execute();
        $row = $sth->fetch(PDO::FETCH_ASSOC);

        $i = 0;
        foreach($row as $column => $value) {

            $meta = $sth->getColumnMeta($i);

            if($meta['sqlite:decl_type'] === 'INTEGER')
            {
                $this->$column = (int) $value;
            }else{
                $this->$column = $value;
            }

            $i++;
        }
    }
}

$pdo = new PDO('sqlite:test.db');
$user = new User($pdo);
$user->load(1);
                            

                
pros: you don’t have to specify the properties of the object and how they relate to the database. The model is able to determine the properties automatically by looking at the schema of the database.
*** Data Transfer Object DTO
    class IssResponse
 {
     /**
      * @var float
      */
     private $latitude;

     /**
      * @var float
      */
     private $longitude;

     public function __construct(array $array)
     {
         $this->latitude = $array['latitude'];
         $this->longitude = $array['longitude'];
     }

     public function getLatitude(): float
     {
         return $this->latitude;
     }


     public function getLongitude(): float
     {
         return $this->longitude;
     }

 }

 final class PositionDTO
 {
 /**
  @var float
 */
 private $latitude;

 /**
  @var float
 */
 private $longitude;

 public function __construct(float $latitude, float $longitude)
 {
 $this->latitude = $latitude;
 $this->longitude = $longitude;
 }

 public function getLatitude(): float
 {
 return $this->latitude;
 }

 public function getLongitude(): float
 {
 return $this->longitude;
 }
 }

            

 "a class with public variables and no functions" clean code str. 100. But in PHP we still can't declare type of variable, just type-hint parameters of methods. Like setters, so we can do it indirectly. Another great benefit it the standard rule is to not have public properties so we can stay consisten with this one. But more of great adventage of if we can make our DTO object immutable. So create only getters, without setters. Add all in constructor.
*** ADR
  http://martinbean.co.uk/blog/2016/10/20/implementing-adr-in-laravel/

*** MVC
**** Controllers
***** are what the user interacts with
***** they receive a request from the user, decide what to do, and send request back
***** it's the only component that interacts with the models
**** Models
***** are where an anpplication's data are stored
***** responsible for storing and retrieving data
***** kno nothing about the user interface
**** Views
***** are what the user sees on the screen
***** they present the data to the user
***** kno nothing about the models
**** Why use MVC?
***** business logic separate from presentation: Separation Of Concerns
***** developer specialisation
****** designers can focus on the front end without worrying about the business logic
****** developers of the models can focus on the business logic or back end without worrying about the look and feel
**** Front controller
***** provide a central entry point for all request. All request are sent through one page 

**** Action suffix
***** _call is exectued for a non-existent or non-public method call
***** Stack
      No it wasn't just a naming convention. It was used to execute some code before or after every controller 'action' method. Like checking is user has logged in. 
   It is based on magic __call function which is executed for a non-existent or non-public method call.
   #+BEGIN_SRC php 

  $controller = new Posts();
  $controller->index();

  class Posts
  {
    public function __call($name, $args)
  {
  //run code before
  call_user_func_array()[$this, "$nameAction"], $args);
  //run code after
  }
    public function indexAction()
  {
  }
  }
   #+END_SRC


   tutorial ended on 31 video
*** MVVM
    Magento was here.
** Antipatterns
 God objects
 Essentially, a God object is an object with either too many methods or too many properties;
 essentially, it's a class that knows too much or does too much. The God object soon becomes
 tightly coupled to (referenced by) lots of other bits of code in the application.
 So what's actually wrong with this? Well, in short, when you have one bit of code tied into
 every single other bit of code, you quickly find a maintenance disaster. If you adjust the
 logic for a method in a God object for one use case, you might find it having unintended
 consequences for another element.

 The flip side to God objects being an anti-pattern is when developing embedded systems.
 Embedded systems are used to process data on anything from a calculator to LED signage;
 they are small chips that are essentially self-contained computers and quite low cost. In this
 use case, with restricted computational power you can often find that programming
 elegance and maintainability become peripheral concerns. Slight performance increase and
 centralization of control can be more important, meaning using God objects can be
 somewhat sensible. Fortunately, PHP is incredibly seldom used to program embedded
 systems, so you are incredibly unlikely to find yourself in this particular situation.

 Another anti-pattern, called Fear of Adding Classes,

 Singleton

 <?php
 class{
 Singleton
 private static $instance;
 public static function getInstance()
 {
 if (null === static::$instance) {
 static::$instance = new static();
 }
 }
 return static::$instance;
 protected function __construct()
 {
 }
 private function __clone()
 {
 }
 private function __wakeup()
 {
 }
 }

 So here are the reasons why this should be avoided:
 They are inherently tightly coupled meaning they are difficult to test, for example
 using unit tests. They even maintain their state throughout the life cycle of the
 application.
 They violate the Single Responsibility Principle by controlling their own creation
 and life cycle.
 Fundamentally, it results in you hiding the dependencies of your application in a
 global instance. You can no longer effectively follow your dependencies around
 your code as you can't follow where they are injected as function arguments.
 They make it ineffective to find the dependency chain should you need to
 analyze it.


  Objects should typically be self-contained; they should
 only know problems about themselves and also should only solve one set of problems, its
 own problems. Anything that isn't relevant to this aim doesn't belong in that class.

 Database as IPC
 Let me clear this up for you; your database isn't a message queuing system. You don't use it
 schedule jobs or queue up tasks to be completed. If you need something to do that, use a
 queuing system. Your database is for data...the clue is in the name; don't shove temporary
 messages in there.
 There are many reasons why this is a bad idea. One major issue is the fact that in databases
 there is no real way to not enforce a policy by which you can guarantee that a double-read
 will not occur, and that is by utilizing row locks. This in turn, results in processes (either
 incoming out outgoing) being blocked, which in turn results in processing only being able
 to be done in a serial fashion.
 Furthermore, in order to check if there is any work to do you end up essentially counting
 the rows of data in the database to see if there is work to do; you run this on a continuous
 basis. MySQL doesn't support push notifications; unlike PostgreSQL it doesn't have the
 NOTIFY command to pair with a LISTEN channel.
 Also note that when you merge a job queue with a database table that stores real data, you
 also invalidate the cache every time you complete a job and update a flag, in turn making
 MySQL far slower.
 In short, it results in your database performing worse and can force it to slow critical
 messages to a standstill. You must be careful not to turn your database into a job queue by
 having this functionality sneak up on you; instead, use the database exclusively for data,
 and bear this in mind when extending your database.
 RabbitMQ provides an open source queuing system with some great PHP SDKs.

 Interface Bloat
 Interfaces shouldn't contain thousands of methods that reference internal operations of the
 class. They should be lightweight and considered a way of guaranteeing that when
 something is queried that it is definitely there.

 Interfaces should be used sparingly; do you actually need an interface if the class is only
 ever going to be implemented once and once alone (and realistically, no one is never going
 to need to tamper with such code?). If so, you might want to consider avoiding an interface
 in such a situation.

 So, let me draw you to one implementation of Interface Bloat. Let's take a look at the
 Pheanstalk interface class in the Pheanstalk open source library (note I have stripped the
 comments to make it more readable):
 <?php
 namespace Pheanstalk;
 interface PheanstalkInterface
 {
 const DEFAULT_PORT = 11300;
 const DEFAULT_DELAY = 0;
 const DEFAULT_PRIORITY = 1024;
 const DEFAULT_TTR = 60;
 const DEFAULT_TUBE = 'default';
 public function setConnection(Connection $connection);
 public function getConnection();
 public function bury($job, $priority = self::DEFAULT_PRIORITY);
 public function delete($job);
 [ 49 ]
 Anti-Patterns
 public function ignore($tube);
 public function kick($max);
 public function kickJob($job);
 public function listTubes();
 public function listTubesWatched($askServer = false);
 public function listTubeUsed($askServer = false);
 public function pauseTube($tube, $delay);
 public function resumeTube($tube);
 public function peek($jobId);
 public function peekReady($tube = null);
 public function peekDelayed($tube = null);
 public function peekBuried($tube = null);
 public function put($data, $priority = self::DEFAULT_PRIORITY, $delay =
 self::DEFAULT_DELAY, $ttr = self::DEFAULT_TTR);
 public function putInTube($tube, $data, $priority =
 self::DEFAULT_PRIORITY, $delay = self::DEFAULT_DELAY, $ttr =
 self::DEFAULT_TTR);
 public function release($job, $priority = self::DEFAULT_PRIORITY,
 $delay = self::DEFAULT_DELAY);
 public function reserve($timeout = null);
 public function reserveFromTube($tube, $timeout = null);
 public function statsJob($job);
 public function statsTube($tube);
 public function stats();
 public function touch($job);
 public function useTube($tube);
 public function watch($tube);
 public function watchOnly($tube);
 }
 Yuck! Notice how even constants have been put in the implement, the one thing you might
 actually want to change. Clearly, this is an interface for a class that can only be
 implemented one way, making the Interface useless.


 Bloated optimization
 Often, developers may trip over themselves trying to optimize their code or their design
 artifacts to a ridiculous extent, often before their code even performs basic functions, or
 even before any code has been created at all. This can rapidly perform issues in production.
 In this section, I wish to discuss three anti-patterns specifically relating to this topic:
 Analysis paralysis
 Bikeshedding
 Premature optimization
 [ 62 ]
 Anti-Patterns
 Analysis paralysis
 In short, this is where a strategy is over-analyzed to the point where progress is slowed
 down, or even stopped entirely in extreme cases. Not only can such solutions become
 obsolete rapidly, they can be made in under-educated circumstances, for example, in a
 meeting where an over-analytic boss tries to dig too deep into detail in advance without
 allowing their developers to actually do some research.
 Over-analyzing a problem and seeking a perfect solution upfront just does not work;
 programmers should seek to refine their solution, not come up with the refined solution up
 front.
 Bikeshedding
 Essentially, this is where analysis paralysis can occur on the basis of some very trivial
 decisions, for example, the color of a log in page. The only fix that's required is to not waste
 time on trivial decisions. Avoid design by committee where possible as the majority of
 people, regardless of how good they think their design skills are, are largely incompetent at
 design.
 Premature optimization
 In this section, so far, I've largely beaten up project managers; no time to beat up
 developers. Often, developers will seek to optimize their code prematurely without having
 educated data-led conclusions to drive where and when optimizations should be made.
 Writing clean and readable code is your first priority; then you can use some great profiling
 tools to determine where your bottlenecks are. XDebug and New Relic are just some of the
 tools that are good at this.
 That said, there are some cases where optimization must be done, particularly on some long
 computational tasks where it can be mission-critical to reduce something from O(N2) time
 to O(N). This said, most simple PHP web apps will have no real need to use this
 consideration.
** Links
   https://designpatternsphp.readthedocs.io/en/latest/
* Tests
** Fixtures
	- http://blog.codeleak.pl/2014/06/test-data-builders-and-object-mother.html
	- https://davedevelopment.co.uk/2015/01/28/test-data-builders.html
* Tools
** symfony serializer
   - https://thomas.jarrand.fr/blog/serialization/
   - https://matthiasnoback.nl/2017/07/designing-a-json-serializer/
   - https://stackoverflow.com/questions/35365141/symfony-serializer-set-circular-reference-global/35365239
   - https://speakerdeck.com/dunglas/mastering-the-symfony-serializer?slide=1
** symfony form
'https://webmozart.io/blog/2015/09/09/value-objects-in-symfony-forms/#data-mappers',
'https://stovepipe.systems/post/rethinking-form-development',
'https://blog.martinhujer.cz/symfony-forms-with-request-objects/',
'https://speakerdeck.com/webmozart/symfony-forms-101',
'http://verraes.net/2013/04/decoupling-symfony2-forms-from-entities/' 
** Code City
https://www.reddit.com/r/PHP/comments/a079r6/php_implementation_of_code_city/
* Jokes
  “There is so much spaghetti I might as well open a restaurant!”
* Metrics
** Cyclomatic Complexity Number (CCN) 
   Counts the available decision paths in a source code to determine it's complexity.
   Each decision path starts with one of the conditional statements from the following list:
   - ?
   - &&
   - ||
   - or
   - and
   - xor
   - case
   - catch
   - elseif
   - for
   - foreach
   - if
   - while

   Cyclomatic Complexity Number is never less than 1, because there’s always at least one code path.
   - 1-4 has low complexity.
   - 5-7 is moderate and still easy to understand.
   - 6-10 has a high complexity.
   - 10+ is very complex and hard to understand.
#+BEGIN_SRC php
final class CyclomaticComplexityNumber
{
    // Class Cyclomatic Complexity = 1
}

final class CyclomaticComplexityNumber
{

    public function one()
    {
        // Function Cyclomatic Complexity = 1
    }

    public function two()
    {
        // Function Cyclomatic Complexity = 1
    }

    // Class Cyclomatic Complexity = 1
}

final class CyclomaticComplexityNumber
{

    public function one()
    {
        if(true){

        }
        // Function Cyclomatic Complexity = 2
    }

    public function two()
    {
        // Function Cyclomatic Complexity = 1
    }

    // Class Cyclomatic Complexity = 1 + 1 = 2
}

final class CyclomaticComplexityNumber
{

    public function one()
    {
        if(true){

        }
        // Function Cyclomatic Complexity = 2
    }

    public function two()
    {
        if(true){

        }
        // Function Cyclomatic Complexity = 2
    }

    // Class Cyclomatic Complexity = 1 + 1 + 1 = 3
}
#+END_SRC

** NPath Complexity
#+BEGIN_SRC php
function foo($a, $b)
{
    if ($a > 10) {
        echo 1;
    } else {
        echo 2;
    }
    if ($a > $b) {
        echo 3;
    } else {
        echo 4;
    }
}
#+END_SRC
So here we have function with 4 possible outcomes, since we have 2 statements that have 2 possible outcomes each (2 * 2 = 4). That means that the functions Npath complexity is 4. If we would add another statement with 2 possible outcomes we would get a complexity of 8 since 2 * 2 * 2 = 8.
* Notepad
1) Accurate predictions are an oxymoron in the real world. You can't predict accurately for things that aren't certain, and in almost all cases, developers won't know the systems they are dealing with fully enough. Moreover, they don't know their own personal efficiency from day to day; it just can't be foreseen accurately.
2) A good property of software is the ability to change 
3) Anyone can take a chance at improving code, but refactoring brings a discipline
of safely making changes (with tests) and leveraging the knowledge accumulated by the software development community (through refactorings).
- After all, like beauty, complexity is in the eye of the beholder. 
- Using new programming languages will bring you new insights and ideas to already known languages. You get a better understanding.
- It's not about clever, crAFTY, PREETY CODE. iT'S ABOUT FAST AND EFFECTIVE COMMUNICATION. It's about communication beetween people.
- Any time someone sees some code that isn't as clear as
 it should be, they should take the opportunity to fix it right
 there and then — or at least within a few minutes. This
 opportunistic refactoring is referred to by Uncle Bob as
 following the boy-scout rule — always leave the code behind
 in a better state than you found it.
* About
  It's a simple site about refactoring in PHP.
  
  You can contact me at slawomir.grochowski@gmail.com, https://twitter.com/s_grochowski, https://www.facebook.com/SlawomirGrochowski
  You can support this site: send some BitCoins 1D8xeRkxssTTLESfGZtPVoqVJDq7MJSqNx , send/buy one of the books I would like to read or just say Hello!
